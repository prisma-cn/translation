---
title: 'Prisma Client API 参考'
metaTitle: 'Prisma Client API (参考)'
metaDescription: 'Prisma Client API 参考文档'
tocDepth: 2
toc: true
---

<TopBlock>

Prisma Client API 参考文档是基于以下架构的：

```prisma
model User {
  id           Int              @id @default(autoincrement())
  name         String?
  email        String           @unique
  profileViews Int              @default(0)
  role         Role             @default(USER)
  coinflips    Boolean[]
  posts        Post[]
  city         String
  country      String
  profile      ExtendedProfile?
  pets         Json
}

model ExtendedProfile {
  id     Int     @id @default(autoincrement())
  userId Int?    @unique
  bio    String?
  User   User?   @relation(fields: [userId], references: [id])
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  published Boolean @default(true)
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
  comments  Json
  views     Int     @default(0)
  likes     Int     @default(0)
}

enum Role {
  USER
  ADMIN
}
```

所有生成的示例类型（如 `UserSelect` 和 `UserWhereUniqueInput`）都基于 `User` 模型。

</TopBlock>

## <inlinecode>PrismaClient</inlinecode>

这一小节描述了 `PrismaClient` 构造函数和其参数。

### 备注

- 参数是在运行时进行验证。

### <inlinecode>数据源(datasource)</inlinecode>

修改 `schema.prisma` 文件中的 `datasource` 部分 - 例如，作为一个集成测试的一部分。参见[数据源](../../../concepts/components/prisma-schema/data-sources) <span class="concept"></span>

#### 属性

| 属性 | 值                            | 描述                                                      |
| ---- | ----------------------------- | --------------------------------------------------------- |
| `db` | `{ url: 'file:./dev_qa.db' }` | 数据库[连接地址](../database-reference/connection-urls)。 |

#### 备注

- 每次添加或重命名数据源时，都需要重新生成 Prisma Client。数据源名称包含在生成的客户端(Prisma Client)中。
- 如果你往 schema 中添加了一个新的数据源，那么你需要重新生成客户端。

#### 例子

##### 通过编程的方式修改数据源(datasource) `url`

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: 'file:./dev_qa.db',
    },
  },
})
```

基于以下`datasource`代码:

```prisma
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}
```

### <inlinecode>log</inlinecode>

确定日志类型和级别。参见[日志](../../../concepts/components/prisma-client/working-with-prismaclient/logging) <span class="concept"></span>

#### 选项

| 选项     | 例子                                                                     | 描述 |
| -------- | ------------------------------------------------------------------------ | ---- |
| 日志级别 | `[ "info", "query" ]`                                                    |      |
| 定义级别 | `[ { level: "info", emit: "event" }, { level: "warn", emit: "stdout" }]` |      |

##### 日志级别

| 名称    | 例子                                                                                                                                                                                                                                                                                                                     |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `query` | 例子: <br />`prisma:query SELECT "public"."User"."id", "public"."User"."email" FROM "public"."User" WHERE ("public"."User"."id") IN (SELECT "t0"."id" FROM "public"."User" AS "t0" INNER JOIN "public"."Post" AS "j0" ON ("j0"."authorId") = ("t0"."id") WHERE ("j0"."views" > $1 AND "t0"."id" IS NOT NULL)) OFFSET $2` |
| `info`  | 例子: <br />`prisma:info Started http server on http://127.0.0.1:58471`                                                                                                                                                                                                                                                  |
| `warn`  | 警告。                                                                                                                                                                                                                                                                                                                   |
| `error` | 错误。                                                                                                                                                                                                                                                                                                                   |

##### 触发格式

| 名称     | 描述                                                           |
| -------- | -------------------------------------------------------------- |
| `stdout` | 参见: [stdout](https://en.wikipedia.org/wiki/Standard_streams) |
| `event`  | 触发你可以订阅的事件。                                         |

#### 参考

```ts file=index.d.ts
log?: Array<LogLevel | LogDefinition>
```

```ts file=index.d.ts
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}
```

##### 事件类型

`query` 类型:

```ts file=index.d.ts
export type QueryEvent = {
  timestamp: Date
  query: string // 发送到数据库的查询
  params: string // 查询参数
  duration: number // 客户端发送查询到数据库的时间间隔 - 不仅是执行查询所需的时间
  target: string
}
```

其他日志级别事件类型:

```ts file=index.d.ts
export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
```

#### 例子

##### 将 `query` 和 `info` 日志记录到 `stdout`

<CodeWithResult>

<cmd>

```ts highlight=3;normal;
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({ log: ['query', 'info'] })

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .catch((e) => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</cmd>

<cmdResult>

```
prisma:info  Starting a postgresql pool with 13 connections.
prisma:info  Started http server
prisma:query SELECT COUNT(*) FROM (SELECT "public"."User"."id" FROM "public"."User" WHERE 1=1 ORDER BY "public"."User"."coinflips" ASC OFFSET $1) AS "sub"
```

</cmdResult>

</CodeWithResult>

##### 将 `query` 事件记录到控制台

<CodeWithResult>
<cmd>

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [{ level: 'query', emit: 'event' }],
})

prisma.$on('query', (e) => {
  console.log(e)
})

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .catch((e) => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</cmd>

<cmdResult>

```js
{
  timestamp: 2020-11-17T10:32:10.898Z,
  query: 'SELECT COUNT(*) FROM (SELECT "public"."User"."id" FROM "public"."User" WHERE 1=1 OFFSET $1) AS "sub"',
  params: '[0]',
  duration: 5,
  target: 'quaint::connector::metrics'
}
```

</cmdResult>

</CodeWithResult>

##### 将 `info`, `warn`, 和 `error` 事件记录到控制台

<CodeWithResult>
<cmd>

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    { level: 'warn', emit: 'event' },
    { level: 'info', emit: 'event' },
    { level: 'error', emit: 'event' },
  ],
})

prisma.$on('warn', (e) => {
  console.log(e)
})

prisma.$on('info', (e) => {
  console.log(e)
})

prisma.$on('error', (e) => {
  console.log(e)
})

async function main() {
  const countUsers = await prisma.user.count({})
}

main()
  .catch((e) => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</cmd>
<cmdResult>

```js
{
  timestamp: 2020-11-17T10:33:24.592Z,
  message: 'Starting a postgresql pool with 13 connections.',
  target: 'quaint::pooled'
}
{
  timestamp: 2020-11-17T10:33:24.637Z,
  message: 'Started http server',
  target: 'query_engine::server'
}
```

</cmdResult>
</CodeWithResult>

### <inlinecode>错误格式化</inlinecode>

确定 Prisma 返回的错误级别和格式。

#### 格式化

| 名称                  | 描述                       |
| --------------------- | -------------------------- |
| `undefined`           | 如果未定义，则默认为无色。 |
| `pretty`              | 开启 pretty 格式化。       |
| `colorless` (default) | 开启 colorless 格式化。    |
| `minimal`             | 开启 minimal 格式化。      |

#### 参考

```ts file=index.d.ts
errorFormat?: ErrorFormat
```

```ts file=index.d.ts
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
```

#### 例子

##### 不设置格式

```ts
const prisma = new PrismaClient({
  // 默认使用 colorless 格式
})
```

##### `pretty` 格式

```ts
const prisma = new PrismaClient({
  errorFormat: 'pretty',
})
```

##### `colorless` 格式

```ts
const prisma = new PrismaClient({
  errorFormat: 'colorless',
})
```

##### `minimal` 格式

```ts
const prisma = new PrismaClient({
  errorFormat: 'minimal',
})
```

### <inlinecode>rejectOnNotFound</inlinecode>

如果记录未找到，使用 `rejectOnNotFound` 参数配置 `findUnique` 和/或 `findFirst`来抛出错误。默认情况下。两个操作都返回 `null`。

### 备注

- 你可以配置 `rejectOnNotFound`作用 [`findUnique`](#findunique) 和 [`findFirst`](#findfirst)的每个请求级别

#### 选项

| 选项                 | 描述                                                                           |
| -------------------- | ------------------------------------------------------------------------------ |
| `RejectOnNotFound`   | 全局启用 (`true` / `false`) _或_ 抛出一个自定义错误。                          |
| `RejectPerOperation` | 针对每个操作启用 (`true` / `false`) _或_ 针对每个操作或数据模型抛出自定义错误. |

#### 参考

```ts file=index.d.ts
rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
```

#### 例子

##### 对`findUnique` 和 `findFirst`全局启用

```ts
const prisma = new PrismaClient({
  rejectOnNotFound: true,
})
```

##### 为特定操作全局启用

```ts
const prisma = new PrismaClient({
  rejectOnNotFound: {
    findUnique: true,
  },
})
```

##### 如果未找到记录，则为每个数据模型和操作抛出自定义错误

```ts
const prisma = new PrismaClient({
  rejectOnNotFound: {
    findFirst: {
      User: (err) => new Error('User error'),
      Post: (err) => new Error('Post error!'),
    },
    findUnique: {
      User: (err) => new Error('User error'),
      Post: (err) => new Error('Post error!'),
    },
  },
})
```

## 模型查询 (Model queries)

使用模型查询来执行 CRUD 操作。参见 [CRUD](../../../concepts/components/prisma-client/crud) <span class="concept"></span>

### <inlinecode>findUnique</inlinecode>

`findUnique` 查询 使用唯一条件来获取单个数据库记录：

- 按 _ID_
- 按 _唯一_(_unique_) 属性

`findUnique` 替代 `findOne` 在 [2.12.0](https://github.com/prisma/prisma/releases/tag/2.12.0) 版本后。

#### 备注

- 对相同的 `select` 和 `where` 参数， Prisma 的 `dataloader` 可以[自动批处理 `findUnique` 查询](../../guides/performance-and-optimization/query-optimization-performance#solving-n1-in-graphql-with-findunique-and-prismas-dataloader)

#### 选项

| 名称               | 示例类型 (`User`)        | 必填   | 描述                                                                                                                       |
| ------------------ | ------------------------ | ------ | -------------------------------------------------------------------------------------------------------------------------- |
| `where`            | `UserWhereUniqueInput`   | **是** | 包含模型的所有唯一字段，以便可以选择各个记录。                                                                             |
| `select`           | `XOR<UserSelect, null>`  | 否     | 指定返回的对象[要包含的属性](../../concepts/components/prisma-client/select-fields)。                                      |
| `include`          | `XOR<UserInclude, null>` | 否     | 指定返回的对象[要加载的关系](../../concepts/components/prisma-client/relation-queries)。                                   |
| `rejectOnNotFound` | `RejectOnNotFound`       | 否     | 如果为 true, 抛出一个 `NotFoundError: No User found error`. 你也可以 [配置开启全局 `rejectOnNotFound`](#rejectonnotfound). |

#### 返回类型

| 返回类型                  | 例子                       | 描述                                                                                                                              |
| ------------------------- | -------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| JavaScript object (typed) | `User`                     |                                                                                                                                   |
| JavaScript object (plain) | `{ title: "Hello world" }` | 使用 `select` 和 `include` 来确定要返回的字段                                                                                     |
| `null`                    | `null`                     | 未找到记录                                                                                                                        |
| Error                     |                            | 如果 `rejectOnNotFound` 为 true, `findUnique` 则抛出错误 (`NotFoundError` 为默认, [可全局自定义](#rejectonnotfound)) 返回 `null`. |

#### 参考

`findUnique` 接受以下输入类型:

```ts file=index.d.ts
export type UserFindUniqueArgs = {
  where: UserWhereUniqueInput
  select?: UserSelect | null
  include?: UserInclude | null
}
```

#### 例子

##### 获取 `id` 为 `42` 的 `User` 记录

```ts
const result = await prisma.user.findUnique({
  where: {
    id: 42,
  },
})
```

##### 获取 `email` 为 `alice@prisma.io` 的 `User` 记录

```ts
const result = await prisma.user.findUnique({
  where: {
    email: 'alice@prisma.io',
  },
})
```

##### 获取 `firstName` 为 `Alice` 并且 `lastName` 为 `Smith` (`@@unique`) 的 `User` 记录

<details><summary>展开示例：User 模型使用 @@unique</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@unique(fields: [firstName, lastName], name: "fullname")
}
```

</details>

```ts
const result = await prisma.user.findUnique({
  where: {
    fullname: {
      // name 属性的 @@unique 属性 - 默认为 firstname_lastname
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

##### 获取 `firstName` 为 `Alice` 并且 `lastName` 为 `Smith` (`@@id`) 的 `User` 记录

<details><summary>展开示例 User 模型为使用 @@id</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@id([firstName, lastName])
}
```

</details>

```ts
const result = await prisma.user.findUnique({
  where: {
    firstName_lastName: {
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

### <inlinecode>findFirst</inlinecode>

`findFirst` 返回第一个匹配您的条件的记录。

#### 选项

| 名称               | 示例类型 (`User`)                                            | 必填 | 描述                                                                                                                                                  |
| ------------------ | ------------------------------------------------------------ | ---- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| `distinct`         | `Enumerable<UserDistinct`<br />`FieldEnum>`                  | 否   | 允许您按特定的字段来过滤掉重复的行。 - 例如仅返回不同标题的“帖子”。                                                                                   |
| `where`            | `UserWhereInput`                                             | 否   | 将模型所有字段包装在一个类型中，以便可以通过任何属性过滤列表。                                                                                        |
| `cursor`           | `UserWhereUniqueInput`                                       | 否   | 指定列表的位置（该值通常指定一个 `id` 或其他唯一值）。                                                                                                |
| `orderBy`          | `XOR<Enumerable<User`<br />`OrderByInput>,UserOrderByInput>` | 否   | 允许您按任何属性对返回的列表进行排序。                                                                                                                |
| `include`          | `XOR<UserInclude, null>`                                     | 否   | [指定急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。                                                     |
| `select`           | `XOR<UserSelect, null>`                                      | 否   | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。                                                            |
| `skip`             | `number`                                                     | 否   | 指定应跳过列表中返回的对象的数量。                                                                                                                    |
| `take`             | `number`                                                     | 否   | 指定应在列表中返回多少个对象。当与 `findFirst` 一起使用时，`take` 隐式为 `1` 或 `-1`。 `findFirst` 仅受值是正值还是负值的影响 -任何负值都会反转列表。 |
| `rejectOnNotFound` | `RejectOnNotFound`                                           | 否   | 如果为 true, 则抛出“NotFoundError: No User found error”。 您还可以[全局配置`rejectOnNotFound`](#rejectonnotfound)。                                   |

#### 返回类型

| 返回类型                  | 例子                       | 描述                                                                                                                                                 |
| ------------------------- | -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| JavaScript object (typed) | `User`                     | 指定要在返回的对象上包含哪些属性。                                                                                                                   |
| JavaScript object (plain) | `{ title: "Hello world" }` | 使用 `select` 和 `include` 来确定要返回的字段。                                                                                                      |
| `null`                    | `null`                     | 记录不存在                                                                                                                                           |
| Error                     |                            | 如果 `rejectOnNotFound` 为 true，`findUnique` 会抛出一个错误（默认情况下为 `NotFoundError`，[全局可自定义](#rejectonnotfound)），而不是返回 `null`。 |

#### 注意

- `findFirst` 在幕后调用 `findMany` 并接受相同的查询选项。
- 当您使用 `findFirst` 查询时传递一个负的 `take` 值会颠倒列表的顺序。

#### 参考

`findFirst` 接受以下输入类型:

```ts file=index.d.ts
export type UserFindFirstArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  rejectOnNotFound?: RejectOnNotFound
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### 例子

参见[过滤条件和运算符](#filter-conditions-and-operators)以例子查看过滤结果。

##### 获取 `name` 字段为 `Alice` 的第一个 `User` 记录

```ts
const user = await prisma.user.findFirst({
  where: { name: 'Alice' },
})
```

##### 获取 `title` 字段以 `A test` 开头的第一个 `Post` 记录，并反转列表（`take`）

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({})

async function main() {
  const a = await prisma.post.create({
    data: {
      title: 'A test 1',
    },
  })

  const b = await prisma.post.create({
    data: {
      title: 'A test 2',
    },
  })

  const c = await prisma.post.findFirst({
    where: {
      title: {
        startsWith: 'A test',
      },
    },
    orderBy: {
      title: 'asc',
    },
    take: -1, // 反转列表
  })
}

main()
```

### <inlinecode>findMany</inlinecode>

<AlgoliaTerm name="apiReference" value="findMany" />

`findMany` 接受一个查询选项，并返回一个列表。

#### 选项

| 名称       | 类型                                                          | 必填 | 描述                                                                                                               |
| ---------- | ------------------------------------------------------------- | ---- | ------------------------------------------------------------------------------------------------------------------ |
| `where`    | `UserWhereInput`                                              | 否   | 将模型所有字段包装在一个类型中，以便可以通过任何属性过滤列。表。                                                   |
| `orderBy`  | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | 否   | 允许您按任何属性对返回的列表进行排序。                                                                             |
| `skip`     | `number`                                                      | 否   | 指定应跳过列表中返回的对象的数量。                                                                                 |
| `cursor`   | `UserWhereUniqueInput`                                        | 否   | 指定列表开始的位置（该值通常指定一个 id 或其他唯一值）。                                                           |
| `take`     | `number`                                                      | 否   | 指定在列表中应该返回多少个对象（从列表的**开头**（正值）或**结尾**（负值）获取，或者从 `cursor` 位置（如果使用）。 |
| `select`   | `XOR<PostSelect, null>`                                       | 否   | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。                         |
| `include`  | `XOR<PostInclude, null>`                                      | 否   | [指定急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。                  |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                           | 否   | 允许您按特定的字段来过滤掉重复的行。 - 例如仅返回不同标题的“帖子”。                                                |

#### 返回类型

| 返回类型                        | 例子                         | 描述                                            |
| ------------------------------- | ---------------------------- | ----------------------------------------------- |
| JavaScript array object (typed) | `User[]`                     |                                                 |
| JavaScript array object (plain) | `[{ title: "Hello world" }]` | 使用 `select` 和 `include` 来确定要返回的字段。 |
| Empty array                     | `[]`                         | 没有找到匹配的记录。                            |

#### 参考

`findMany` 接受以下输入类型:

```ts file=index.d.ts
export type UserFindManyArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### 例子

参见 [过滤条件和运算符](#filter-conditions-and-operators) 以获取更多示例。

##### 获取所有 `name` 字段的值为 `Alice` 的 `User` 记录。

```ts
const user = await prisma.user.findMany({
  where: { name: 'Alice' },
})
```

### <inlinecode>create</inlinecode>

`create` 创建一条新的数据库记录。

#### 选项

| 名称                  | 类型                                                     | 必填   | 描述                                                                                                                                                           |
| --------------------- | -------------------------------------------------------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`                | `XOR<UserCreateInput,` <br />`UserUncheckedCreateInput>` | **是** | 将所有模型字段包装在一个类型中，以便在创建新记录时提供它们。它还包括允许您执行（事务性）嵌套插入的关系字段。在数据模型中标记为可选或具有默认值的字段是可选的。 |
| [`select`](#select)   | `XOR<UserSelect, null>`                                  | 否     | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。                                                                     |
| [`include`](#include) | `XOR<UserInclude, null>`                                 | 否     | [指定应急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。                                                            |

#### 返回类型

| 返回类型                  | 例子                           | 描述                                            |
| ------------------------- | ------------------------------ | ----------------------------------------------- |
| JavaScript object (typed) | `User`                         |                                                 |
| JavaScript object (plain) | `{ name: "Alice Wonderland" }` | 使用 `select` 和 `include` 来确定要返回的字段。 |

#### 注意

- 你可以使用 [`create`](#create-1) 来执行嵌套创建。例如，你可以同时创建一条 `User` 和两条 `Post` 记录。

#### 参考

`create` 接受以下输入类型:

```ts file=index.d.ts
export type UserCreateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserCreateInput, UserUncheckedCreateInput>
}
```

#### 例子

##### 创建一个只有 `email` 字段的新记录

```ts
const user = await prisma.user.create({
  data: { email: 'alice@prisma.io' },
})
```

##### 创建多个新记录

Prisma Client 不支持在数据库级别批量插入。请查看 [issue #332 on GitHub](https://github.com/prisma/prisma-client-js/issues/332) 更新。

以下示例结果产生 **两个** `INSERT` 语句:

<CodeWithResult expanded={true}>

<cmd>

```ts
import { PrismaClient, UserCreateInput } from '@prisma/client'

const prisma = new PrismaClient({ log: ['query'] })

async function main() {
  let users: UserCreateInput[] = [
    {
      email: 'ariana@prisma.io',
      name: 'Ari',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
    {
      email: 'elsa@prisma.io',
      name: 'Elsa',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
  ]

  await Promise.all(
    users.map(async (user) => {
      await prisma.user.create({
        data: user,
      })
    })
  )
}

main()
  .catch((e) => {
    throw e
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

</cmd>

<cmdResult>

```sql
prisma:query BEGIN
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query COMMIT
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query COMMIT
```

</cmdResult>

</CodeWithResult>

### <inlinecode>update</inlinecode>

`update` 更新现有的数据库记录。

#### 选项

| 名称                  | 类型                                                   | 必填   | 描述                                                                                                     |
| --------------------- | ------------------------------------------------------ | ------ | -------------------------------------------------------------------------------------------------------- |
| `data`                | `XOR<UserUpdateInput`<br />`UserUncheckedUpdateInput>` | **是** | 包装模型的所有字段，以便在更新现有记录时可以提供它们。在数据模型中标记为可选或具有默认值的字段是可选的。 |
| `where`               | `UserWhereUniqueInput`                                 | **是** | 包装模型的所有 _unique_ 字段，以便可以选择单个记录。                                                     |
| [`select`](#select)   | `XOR<UserSelect, null>`                                | 否     | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。               |
| [`include`](#include) | `XOR<UserInclude, null>`                               | 否     | [指定应急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。      |

#### 返回类型

| 返回类型                   | 例子                           | 描述                                            |
| -------------------------- | ------------------------------ | ----------------------------------------------- |
| JavaScript object (typed)  | `User`                         |                                                 |
| JavaScript object (plain)  | `{ name: "Alice Wonderland" }` | 使用 `select` 和 `include` 来确定要返回的字段。 |
| `RecordNotFound` exception |                                | 如果记录不存在则抛出异常。                      |

#### 注意

- 要对更新（加、减、乘、除）执行算术运算，请使用 [原子更新(atomic updates)](#atomic-number-operations) 来防止竞争条件。
- 您还可以执行嵌套的 [`update`](#update-1) -例如，同时更新用户和该用户的帖子。

#### 参考

```ts file=index.d.ts
export type UserUpdateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  where: UserWhereUniqueInput
}
```

#### 例子

##### 将 `id` 为 `1` 的 `User` 记录的 `email` 更新为 `alice@prisma.io`

```ts
const user = await prisma.user.update({
  where: { id: 1 },
  data: { email: 'alice@prisma.io' },
})
```

### <inlinecode>upsert</inlinecode>

`upsert` 更新现有的*或*创建新的数据库记录。

#### 选项

| 名称                  | 类型                                                    | 必填   | 描述                                                                                                                                               |
| --------------------- | ------------------------------------------------------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| `create`              | `XOR<UserCreateInput,`<br />`UserUncheckedCreateInput>` | **是** | 包装模型的所有字段，以便在创建新记录时提供它们。它还包括允许您执行（事务性）嵌套插入的关系字段。在数据模型中标记为可选或具有默认值的字段是可选的。 |
| `update`              | `XOR<UserUpdateInput,`<br />`UserUncheckedUpdateInput>` | **是** | 包装模型的所有字段，以便在更新现有记录时可以提供它们。在数据模型中标记为可选或具有默认值的字段是可选的。                                           |
| `where`               | `UserWhereUniqueInput`                                  | **是** | 包装模型的所有 _unique_ 字段，以便可以选择单个记录。                                                                                               |
| [`select`](#select)   | `XOR<UserSelect, null>`                                 | 否     | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。                                                         |
| [`include`](#include) | `XOR<UserInclude, null>`                                | 否     | [指定应急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。                                                |

#### 返回类型

| 返回类型                  | 例子                           | 例子                                            |
| ------------------------- | ------------------------------ | ----------------------------------------------- |
| JavaScript object (typed) | `User`                         |                                                 |
| JavaScript object (plain) | `{ name: "Alice Wonderland" }` | 使用 `select` 和 `include` 来确定要返回的字段。 |

#### 注意

- 要对更新（加、减、乘、除）执行算术运算，请使用 [原子更新(atomic updates)](#atomic-number-operations) 来防止竞争条件。

#### 参考

`upsert` 接受以下输入类型:

```ts file=index.d.ts
export type UserUpsertArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
  create: XOR<UserCreateInput, UserUncheckedCreateInput>
  update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
}
```

#### 例子

##### 更新（如果存在）或创建一条 `email` 为 `alice@prisma.io` 的 `User` 记录

```ts
const user = await prisma.user.upsert({
  where: { id: 1 },
  update: { email: 'alice@prisma.io' },
  create: { email: 'alice@prisma.io' },
})
```

### <inlinecode>delete</inlinecode>

`delete` 删除现有的数据库记录。您可以删除记录:

- 按 _ID_
- 按一个 _unique_ 属性

要删除符合特定条件的记录，请使用带过滤器的 [`deleteMany`](#deleteMany)。

#### 选项

| 名称                  | 类型                     | 必填   | 描述                                                                                                |
| --------------------- | ------------------------ | ------ | --------------------------------------------------------------------------------------------------- |
| `where`               | `UserWhereUniqueInput`   | **是** | 包装模型的所有 _unique_ 字段，以便可以选择单个记录。                                                |
| [`select`](#select)   | `XOR<UserSelect, null>`  | 否     | [指定要包含的属性](../../concepts/components/prisma-client/select-fields) 在返回的对象上。          |
| [`include`](#include) | `XOR<UserInclude, null>` | 否     | [指定应急切加载哪些关系](../../concepts/components/prisma-client/relation-queries) 在返回的对象上。 |

#### 返回类型

| 返回类型                  | 例子                           | 描述                                                                           |
| ------------------------- | ------------------------------ | ------------------------------------------------------------------------------ |
| JavaScript object (typed) | `User`                         | 被删除的 `User` 记录。                                                         |
| JavaScript object (plain) | `{ name: "Alice Wonderland" }` | 数据来自已删除的 `User` 记录。 使用 `select` 和 `include` 来确定要返回的字段。 |
| `RecordNotFound` 异常     |                                | 如果记录不存在则抛出异常。                                                     |

#### 注意

- 要根据某些条件删除多条记录（例如，所有带有 `prisma.io` 电子邮件地址的 `User` 记录，请使用 `deleteMany`）

#### 参考

`delete` 接受以下输入类型:

```ts file=index.d.ts
export type UserDeleteArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
}
```

#### 例子

##### 删除 `id` 为 `1` 的 `User` 记录

```ts
const user = await prisma.user.delete({
  where: { id: 1 },
})
```

##### 删除 `email` 为 `else@prisma.io` 的 `User` 记录

以下查询会删除特定用户记录并使用 `select` 返回被删除用户的 `name` 和 `email`：

<CodeWithResult expanded="{true}">

<cmd>

```ts
const deleteUser = await prisma.user.delete({
  where: {
    email: 'elsa@prisma.io',
  },
  select: {
    email: true,
    name: true,
  },
})
```

</cmd>

<cmdResult>

```json
{ "email": "elsa@prisma.io", "name": "Elsa" }
```

</cmdResult>

</CodeWithResult>

### <inlinecode>createMany</inlinecode>

`createMany` 在一个事务中创建多个记录。

#### 选项

| 名称              | 类型                              | 必填   | 描述                                                                                                                                                            |
| ----------------- | --------------------------------- | ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`            | `Enumerable<UserCreateManyInput>` | **是** | 将所有模型字段包装在一个类型中，以便在创建新记录时提供它们。它还包括允许您执行（事务性）嵌套插入的关系字段。在数据模型中标记为可选或具有默认值的字段是可选的。  |
| `skipDuplicates?` | `boolean`                         | 否     | 不要插入具有唯一字段或已存在的 ID 字段的记录。仅受支持的数据库支持 [`在冲突中什么都不做`](https://www.postgresql.org/docs/9.5/sql-insert.html#SQL-ON-CONFLICT). |

#### 返回类型

| 返回类型       | 例子           | 描述                 |
| -------------- | -------------- | -------------------- |
| `BatchPayload` | `{ count: 3 }` | 创建的记录的总条数。 |

#### 注意

- `createMany` 不支持 SqLite。
- 你 **不能** 创建或连接关系 - 你不能在一个顶级 `createMany` 中嵌套 `create`, `createMany`, `connect`, `connectOrCreate`。
- 你可以在一个 [`createMany`](#createmany-1) 中嵌套多个 `create` 或 `update` 查询 - 例如，在同一个 `createMany` 中添加一个 `User` 和两个 `Post` 记录。

#### 参考

`createMany` 接受以下输入类型:

```ts file=index.d.ts
export type UserCreateManyArgs = {
  data: Enumerable<UserCreateManyInput>
  skipDuplicates?: boolean
}
```

#### 例子

##### 创建一些新用户

```ts
const users = await prisma.user.createMany({
  data: [
    { name: 'Sonali', email: 'sonali@prisma.io' },
    { name: 'Alex', email: 'alex@prisma.io' },
  ],
})
```

### <inlinecode>updateMany</inlinecode>

`updateMany` 更新一批已存在的数据库记录并返回更新的记录数。

#### 选项

| 名称    | 类型                                                                    | 必填   | 描述                                                                                                                 |
| ------- | ----------------------------------------------------------------------- | ------ | -------------------------------------------------------------------------------------------------------------------- |
| `data`  | `XOR<UserUpdateManyMutationInput,`<br />`UserUncheckedUpdateManyInput>` | **是** | 包装模型的所有字段，以便在更新现有记录时可以提供它们。在数据模型中标记为可选或具有默认值的字段在 `data` 上是可选的。 |
| `where` | `UserWhereInput`                                                        | 否     | 包装模型的 _所有_ 字段，以便可以通过任何属性过滤列表。如果您不过滤列表，所有记录都将被更新。                         |

#### 返回类型

| 返回类型       | 例子           | 描述               |
| -------------- | -------------- | ------------------ |
| `BatchPayload` | `{ count: 4 }` | 更新记录的总条数。 |

```ts
export type BatchPayload = {
  count: number
}
```

#### 参考

`updateMany` 接受以下输入类型:

```ts file=index.d.ts
export type UserUpdateManyArgs = {
  data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
  where?: UserWhereInput
}
```

#### 例子

##### 将所有 `name` 字段为 `Alice` 的 `User` 的 `name` 更新为 `ALICE`

```ts
const updatedUserCount = await prisma.user.updateMany({
  where: { name: 'Alice' },
  data: { name: 'ALICE' },
})
```

##### 更新所有 `email` 包含 `prisma.io` 且 `Post`的 likes 大于 10 的所有 `用户` 记录。

```ts
const deleteUser = await prisma.user.updateMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
    posts: {
      some: {
        likes: {
          gt: 10,
        },
      },
    },
  },
  data: {
    role: 'USER',
  },
})
```

### <inlinecode>deleteMany</inlinecode>

`deleteMany` 删除的多条记录。

#### 选项

| 名称    | 类型             | 必填 | 描述                                                 |
| ------- | ---------------- | ---- | ---------------------------------------------------- |
| `where` | `UserWhereInput` | 否   | 包装模型的 _所有_ 字段，以便可以按任何字段过滤列表。 |

#### 返回类型

| 返回类型       | 例子           | 描述             |
| -------------- | -------------- | ---------------- |
| `BatchPayload` | `{ count: 4 }` | 更新记录的条数。 |

```ts
export type BatchPayload = {
  count: number
}
```

#### 参考

`deleteMany` 接受以下输入类型:

```ts file=index.d.ts
export type UserDeleteManyArgs = {
  where?: UserWhereInput
}
```

#### 例子

##### 删除所有 `User` 记录

```ts
const deletedUserCount = await prisma.user.deleteMany({})
```

##### 删除所有 `name` 为 `Alice` 的 `User` 记录

```ts
const deletedUserCount = await prisma.user.deleteMany({
  where: { name: 'Alice' },
})
```

有关如何过滤要删除的记录的示例，请参阅[过滤条件和运算符](#filter-conditions-and-operators)。

### <inlinecode>count</inlinecode>

#### 选项

| 名称       | 类型                                                          | 必填 | 描述                                                                                                               |
| ---------- | ------------------------------------------------------------- | ---- | ------------------------------------------------------------------------------------------------------------------ |
| `where`    | `UserWhereInput`                                              | 否   | 将*所有*模型字段包装在一个类型中，以便可以通过任何属性过滤列表。                                                   |
| `cursor`   | `UserWhereUniqueInput`                                        | 否   | 指定列表的位置（该值通常指定一个 `id` 或另一个唯一值）。                                                           |
| `skip`     | `number`                                                      | 否   | 指定应跳过列表中返回的对象的数量。                                                                                 |
| `take`     | `number`                                                      | 否   | 指定在列表中应该返回多少个对象（从列表的**开头**（正值）或**结尾**（负值）获取，或者从 `cursor` 位置（如果使用）。 |
| `orderBy`  | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | 否   | 允许您按任何属性对返回的列表进行排序。                                                                             |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                           | 否   | 允许您按特定字段过滤掉重复的行 -例如，仅返回不同的 `Post` 标题。                                                   |
| `select`   | `UserCountAggregateInputType`                                 | 否   | 选择要计算的字段（非 `null` 值） -您也可以计算`_all`。                                                             |

#### 返回类型

| 返回类型                       | 例子                     | 描述                          |
| ------------------------------ | ------------------------ | ----------------------------- |
| `number`                       | `29`                     | 记录条数。                    |
| `UserCountAggregateOutputType` | `{ _all: 27, name: 10 }` | 如果使用了 `select`，则返回。 |

#### 参考

`count` 接受以下输入类型:

```ts file=index.d.ts
export type UserFindManyArgs = {
  // select and include are excluded
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}

export type UserCountAggregateOutputType = {
  id: number
  name: number | null
  email: number | null
  profileViews: number
  role: number | null
  coinflips: number | null
  testing: number | null
  city: number | null
  country: number | null
  _all: number
}
```

#### 例子

##### 统计所有 `User` 记录共有多少条

```ts
const result = await prisma.user.count()
```

##### 统计所有 `User` 记录共有多少条，其中至少有一条已发布的 `Post`

```ts
const result = await prisma.user.count({
  where: {
    post: {
      some: {
        published: true,
      },
    },
  },
})
```

##### 使用 `select` 来执行三个分别统计

以下查询返回:

- 所有记录的总数（`_all`）
- 具有 非`null` `name` 字段的所有记录的计数
- 具有 非`null` `city` 字段的所有记录的计数

```ts
const c = await prisma.user.count({
  select: {
    _all: true,
    city: true,
    name: true,
  },
})
```

### <inlinecode>aggregate</inlinecode>

参见：[聚合，分组和汇总](../../../concepts/components/prisma-client/aggregation-grouping-summarizing#aggregate) <span class="concept"></span>

#### 选项

| 名称       | 类型                                                         | 必填 | 描述                                                                                                               |
| ---------- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------------------------------------------------------------ |
| `where`    | `UserWhereInput`                                             | 否   | 将*所有*模型字段包装在一个类型中，以便可以通过任何属性过滤列表。                                                   |
| `orderBy`  | `XOR<Enumerable<UserOrderByInput>,`<br />`UserOrderByInput>` | 否   | 允许您按任何属性对返回的列表进行排序。                                                                             |
| `cursor`   | `UserWhereUniqueInput`                                       | 否   | 指定列表的位置（该值通常指定一个 `id` 或另一个唯一值）。                                                           |
| `skip`     | `number`                                                     | 否   | 指定应跳过列表中返回的对象的数量。                                                                                 |
| `take`     | `number`                                                     | 否   | 指定在列表中应该返回多少个对象（从列表的**开头**（正值）或**结尾**（负值）获取，或者从 `cursor` 位置（如果使用）。 |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                          | 否   | 允许您按特定字段过滤掉重复的行 -例如，仅返回不同的 `Post` 标题。                                                   |
| `_count`   | `true`                                                       | 否   | 返回匹配记录或非空字段的数量。                                                                                     |
| `_avg`     | `UserAvgAggregateInputType`                                  | 否   | 返回指定字段的所有值的平均值。                                                                                     |
| `_sum`     | `UserSumAggregateInputType`                                  | 否   | 返回指定字段的所有值的总和。                                                                                       |
| `_min`     | `UserMinAggregateInputType`                                  | 否   | 返回指定字段的最小可用值。                                                                                         |
| `_max`     | `UserMaxAggregateInputType`                                  | 否   | 返回指定字段的最大可用值。                                                                                         |

#### 参考

`aggregate` 接受以下输入类型:

```ts file=index.d.ts
export type UserAggregateArgs = {
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
  _count?: true | UserCountAggregateInputType
  _avg?: UserAvgAggregateInputType
  _sum?: UserSumAggregateInputType
  _min?: UserMinAggregateInputType
  _max?: UserMaxAggregateInputType
}
```

#### 例子

##### 返回所有 `User` 记录的 `profileViews` 的 `_min`、`_max` 和 `_count`

<CodeWithResult>
<cmd>

```ts
const minMaxAge = await prisma.user.aggregate({
  _count: {
    _all: true,
  },
  _max: {
    profileViews: true,
  },
  _min: {
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js
{
  _count: { _all: 29 },
  _max: { profileViews: 90 },
  _min: { profileViews: 0 }
}
```

</cmdResult>
</CodeWithResult>

##### 返回所有 `User` 记录的 `profileViews` 的 `_sum`

<CodeWithResult>
<cmd>

```ts
const setValue = await prisma.user.aggregate({
  _sum: {
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js
{
  "_sum": {
    "profileViews": 9493
  }
}
```

</cmdResult>
</CodeWithResult>

### <inlinecode>groupBy</inlinecode>

参见: [聚合, 分组和汇总](../../../concepts/components/prisma-client/aggregation-grouping-summarizing#group-by) <span class="concept"></span>

#### 选项

| 名称      | 类型                                                         | 必填 | 描述                                                                                                               |
| --------- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------------------------------------------------------------ |
| `where`   | `UserWhereInput`                                             | 否   | 将*所有*模型字段包装在一个类型中，以便可以通过任何属性过滤列表。                                                   |
| `orderBy` | `XOR<Enumerable<UserOrderByInput>,`<br />`UserOrderByInput>` | 否   | 允许您按也存在于 `by` 中的任何属性对返回的列表进行排序。                                                           |
| `by`      | `Array<UserScalarFieldEnum>`                                 | 否   | 指定作为记录分组依据的字段或字段组合。                                                                             |
| `having`  | `UserScalarWhereWithAggregatesInput`                         | 否   | 允许您按聚合值过滤组 -例如，仅返回平均年龄小于 50 岁的组。                                                         |
| `skip`    | `number`                                                     | 否   | 指定应跳过列表中返回的对象的数量。                                                                                 |
| `take`    | `number`                                                     | 否   | 指定在列表中应该返回多少个对象（从列表的**开头**（正值）或**结尾**（负值）获取，或者从 `cursor` 位置（如果使用）。 |
| `_count`  | `true`                                                       | 否   | 返回匹配记录或非空字段的数量。                                                                                     |
| `_avg`    | `UserAvgAggregateInputType`                                  | 否   | 返回指定字段的所有值的平均值。                                                                                     |
| `_sum`    | `UserSumAggregateInputType`                                  | 否   | 返回指定字段的所有值的总和。                                                                                       |
| `_min`    | `UserMinAggregateInputType`                                  | 否   | 返回指定字段的最小可用值。                                                                                         |
| `_max`    | `UserMaxAggregateInputType`                                  | 否   | 返回指定字段的最大可用值。                                                                                         |

#### 参考

`groupBy` 接受以下输入类型:

```ts file=index.d.ts
export type UserGroupByArgs = {
  where?: UserWhereInput
  orderBy?: Enumerable<UserOrderByInput>
  by: Array<UserScalarFieldEnum>
  having?: UserScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: true | UserCountAggregateInputType
  _avg?: UserAvgAggregateInputType
  _sum?: UserSumAggregateInputType
  _min?: UserMinAggregateInputType
  _max?: UserMaxAggregateInputType
}
```

#### 例子

##### 按平均 `profileViews` 大于 `200` 的 `country`/`city` 分组，并返回每组 `profileViews` 的 `_sum`

该查询还返回每个组中 `_all` 记录的计数，以及每个组中具有非 `null` `city` 字段值的所有记录。

<CodeWithResult expanded="{true}">
<cmd>

```ts
const groupUsers = await prisma.user.groupBy({
  by: ['country', 'city'],
  _count: {
    _all: true,
    city: true,
  },
  _sum: {
    profileViews: true,
  },
  orderBy: {
    country: 'desc',
  },
  having: {
    profileViews: {
      _avg: {
        gt: 200,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```js
;[
  {
    country: 'Denmark',
    city: 'Copenhagen',
    _sum: { profileViews: 490 },
    _count: {
      _all: 70,
      city: 8,
    },
  },
  {
    country: 'Sweden',
    city: 'Stockholm',
    _sum: { profileViews: 500 },
    _count: {
      _all: 50,
      city: 3,
    },
  },
]
```

</cmdResult>
</CodeWithResult>

## 模型查询选项

### <inlinecode>select</inlinecode>

`select` 定义了 Prisma Client 返回的对象中包含哪些字段。请参阅：[选择字段并包含关系](../../../concepts/components/prisma-client/select-fields) <span class="concept"></span>。

#### 注意

- 您不能在同一级别上组合使用 `select` 和 `include`。
- 在 [2.20.0](https://github.com/prisma/prisma/releases/2.20.0)及更高版本, 你可以[选择一个`_count`个关系](#select-a-_count-of-relations).

#### 参考

```ts file=index.d.ts
export type UserSelect = {
  id?: boolean
  name?: boolean
  email?: boolean
  profileViews?: boolean
  role?: boolean
  coinflips?: boolean
  posts?: boolean | PostFindManyArgs
  _count?: boolean | UserCountOutputTypeArgs
}
```

#### 例子

##### 选择返回的 `User` 对象中包含 `name` 和 `profileViews` 字段

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findUnique({
  where: { id: 1 },
  select: {
    name: true,
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js
{
  name: "Alice",
  profileViews: 0
}
```

</cmdResult>
</CodeWithResult>

##### 选择多个 `User` 记录的 `name` 和 `profileViews` 字段

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
})
```

</cmd>
<cmdResult>

```js
;[
  {
    email: 'alice@prisma.io',
    role: 'ADMIN',
  },
  {
    email: 'bob@prisma.io',
    role: 'USER',
  },
]
```

</cmdResult>
</CodeWithResult>

##### 选择一个 `_count` 关系

<CodeWithResult>
<cmd>

```ts
const usersWithCount = await prisma.user.findMany({
  select: {
    _count: {
      select: { posts: true },
    },
  },
})
```

</cmd>
<cmdResult>

```js
{
  _count: {
    posts: 3
  }
}
```

</cmdResult>
</CodeWithResult>

##### 选择 `Post` 关系中的 `id` 和 `title` 字段

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    posts: {
      select: {
        id: true,
        title: true,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```ts
;[
  {
    id: 1,
    name: 'Alice',
    posts: [
      { id: 1, title: 'Hello World' },
      { id: 2, title: 'Bye bye' },
    ],
  },
  {
    id: 2,
    name: 'Bob',
    posts: [],
  },
]
```

</cmdResult>
</CodeWithResult>

##### `include` 在 `select` 中

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    posts: {
      include: {
        author: true,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```js
;[
  {
    id: 1,
    name: 'Alice',
    posts: [
      {
        id: 1,
        title: 'Hello World',
        published: true,
        author: {
          id: 1,
          name: 'Alice',
          email: 'alice@prisma.io',
          role: 'ADMIN',
          coinflips: [true, false],
          profileViews: 0,
        },
      },
      {
        id: 2,
        title: 'Bye bye',
        published: false,
        author: {
          id: 1,
          name: 'Alice',
          email: 'alice@prisma.io',
          role: 'USER',
          coinflips: [],
          profileViews: 0,
        },
      },
    ],
  },
]
```

</cmdResult>
</CodeWithResult>

#### `select` 的生成类型

以下示例演示了如何将 [`validator`](../../concepts/components/prisma-client/advanced-type-safety/prisma-validator) 与 `select` 结合使用：

- `SelectAndInclude`
- `UserSelect`

```ts
// SelectAndInclude
const selectNameIncludeEmail = Prisma.validator<Prisma.SelectAndInclude>()({
  select: {
    name: true,
  },
  include: {
    email: true,
  },
})

// UserSelect
const selectNameEmailNotPosts = Prisma.validator<Prisma.UserSelect>()({
  name: true,
  email: true,
  posts: false,
})
```

### <inlinecode>include</inlinecode>

`include` 定义了 Prisma 客户端返回的结果中包含哪些关系。请参阅：[选择字段并包含关系](../../../concepts/components/prisma-client/select-fields) <span class="concept"></span>。

#### 注意

- 在 [2.20.0](https://github.com/prisma/prisma/releases/2.20.0) 和更高版本, 你可以[`include`一个`_count`的关系](#include-a-_count-of-relations)

#### 参考

```ts
export type UserInclude = {
  posts?: boolean | PostFindManyArgs
  _count?: boolean | UserCountOutputTypeArgs
}
```

#### 例子

##### 加载 `User` 记录时包含 `posts` 和 `profile` 关系

```ts
const users = await prisma.user.findMany({
  include: {
    posts: true, // Returns all fields for all posts
    profile: true, // Returns all Profile fields
  },
})
```

##### 在创建一个有两条 `Post` 记录的新 `User` 记录时，在返回的对象上包括 `posts` 关系

```ts
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [
        { title: 'This is my first post' },
        { title: 'Here comes a second post' },
      ],
    },
  },
  include: { posts: true }, // Returns all fields for all posts
})
```

#### `include` 的生成类型

以下示例演示了如何将 [`validator`](../../concepts/components/prisma-client/advanced-type-safety/prisma-validator) 与 `include` 一起使用：

- `SelectAndInclude`
- `UserInclude`

```ts
// SelectAndInclude
const selectNameIncludeEmail = Prisma.validator<Prisma.SelectAndInclude>()({
  select: {
    name: true,
  },
  include: {
    email: true,
  },
})

// UserInclude
const includePosts = Prisma.validator<Prisma.UserInclude>()({
  posts: true,
})
```

##### 加载一个 `_count` 的关系

<CodeWithResult>
<cmd>

```ts
const usersWithCount = await prisma.user.findMany({
  include: {
    _count: {
      select: { posts: true },
    },
  },
})
```

</cmd>
<cmdResult>

```js
{ id: 1, name: "Bob", email: "bob@prisma.io", _count: { posts: 3 } },
{ id: 2,  name: "Enya", email: "enya@prisma.io", _count: { posts: 2 } }
```

</cmdResult>
</CodeWithResult>

### <inlinecode>where</inlinecode>

`where` 定义了一个或多个 [过滤器](#filter-conditions-and-operators)，可用于过滤记录属性（如用户的电子邮件地址）或相关记录属性（如用户最近的前 10 篇帖子）标题）。

#### 参考

对于像 `findMany` 和 `updateMany` 这样返回多条记录的查询, `where` 接受以下输入类型:

```ts file=index.d.ts
export type UserWhereInput = {
  AND?: Enumerable<UserWhereInput>
  OR?: Enumerable<UserWhereInput>
  NOT?: Enumerable<UserWhereInput>
  id?: IntFilter | number
  name?: StringNullableFilter | string | null
  email?: StringFilter | string
  profileViews?: IntFilter | number
  role?: EnumRoleFilter | Role
  coinflips?: BoolNullableListFilter
  posts?: PostListRelationFilter
}
```

> `findFirst` 是一个带有 `take: 1` 的 `findMany` 查询，并且也接受 `UserWhereInput`。

对于像 `findUnique` 这样的查询，它通过 ID 或唯一标识符返回单个记录, `where` 接受以下输入类型:

```ts file=index.d.ts
export type UserWhereUniqueInput = {
  id?: number
  email?: string
}
```

#### 例子

```ts
const results = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
    },
  },
})
```

#### `where` 的生成类型

以下示例演示了如何将 [`validator`](../../concepts/components/prisma-client/advanced-type-safety/prisma-validator) 与 `where` 结合使用：

- `UserWhereInput`

```ts
// UserWhereInput
const whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({
  name: 'Rich',
})

// It can be combined with conditional operators too
const whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({
  name: 'Rich',
  AND: [
    {
      email: {
        contains: 'rich@boop.com',
      },
    },
  ],
})
```

- `UserWhereUniqueInput` 这种类型的工作原理是公开模型上的任何唯一字段。分配了 `@id` 的字段被认为是唯一的，
  正如一个分配的 `@unique`。

```ts
// UserWhereUniqueInput
const whereEmailIsUnique = Prisma.validator<Prisma.UserWhereUniqueInput>()({
  email: 'rich@boop.com',
})
```

- `PostScalarWhereInput`

```ts
const whereScalarTitleIs = Prisma.validator<Prisma.PostScalarWhereInput>()({
  title: 'boop',
})
```

- `PostUpdateWithWhereUniqueWithoutAuthorInput` - 此类型接受唯一的 `where` 字段（`@id` 或其他分配的 `@unique`）
  并更新 `Post` 模型上除 `Author` 之外的任何字段。 `Author` 是 `Post` 模型上的标量字段。

```ts
const updatePostByIdWithoutAuthor =
  Prisma.validator<Prisma.PostUpdateWithWhereUniqueWithoutAuthorInput>()({
    where: {
      id: 1,
    },
    data: {
      content: 'This is some updated content',
      published: true,
      title: 'This is a new title',
    },
  })
```

- `PostUpsertWithWhereUniqueWithoutAuthorInput` - 此类型将更新 id 匹配的 `Post` 记录标题字段，如果它不存在，它将改为创建它。

```ts
const updatePostTitleOrCreateIfNotExist =
  Prisma.validator<Prisma.PostUpsertWithWhereUniqueWithoutAuthorInput>()({
    where: {
      id: 1,
    },
    update: {
      title: 'This is a new title',
    },
    create: {
      id: 1,
      title: 'If the title doesnt exist, then create one with this text',
    },
  })
```

- `PostUpdateManyWithWhereWithoutAuthorInput` - 这种类型将更新所有发布为 false 的 `Post` 记录。

```ts
const publishAllPosts =
  Prisma.validator<Prisma.PostUpdateManyWithWhereWithoutAuthorInput>()({
    where: {
      published: {
        equals: false,
      },
    },
    data: {
      published: true,
    },
  })
```

### <inlinecode>orderBy</inlinecode>

对记录列表进行排序。另请参阅：[排序](../../../concepts/components/prisma-client/filtering-and-sorting) <span class="concept"></span>

#### 注意

- 在 [2.16.0](https://github.com/prisma/prisma/releases/2.16.0) 和更高版本, 您可以[按关系字段排序](#sort-post-by-the-related-user-records-name) (预览)-例如，按作者的名字排列文章

#### 输入

| 名称   | 描述              |
| ------ | ----------------- |
| `asc`  | 升序 (A &rarr; Z) |
| `desc` | 降序 (Z &rarr; A) |

#### 参考

`orderBy` 接受以下输入类型:

```ts file=index.d.ts
export type UserOrderByInput = {
  id?: SortOrder
  name?: SortOrder
  email?: SortOrder
  profileViews?: SortOrder
  role?: SortOrder
  coinflips?: SortOrder
  posts?: PostOrderByAggregateInput
  profile?: ExtendedProfileOrderByWithRelationInput
}
```

相关类型：

```ts
export type PostOrderByAggregateInput = {
  count: SortOrder
}

export type ExtendedProfileOrderByWithRelationInput = {
  id?: SortOrder
  biograpy?: SortOrder
  userId?: SortOrder
  user?: UserOrderByWithRelationInput
}

export declare const SortOrder: {
  asc: 'asc'
  desc: 'desc'
}
```

#### 例子

##### 按 `email` 字段排序 `User` 记录

以下示例按 `email` 升序排序 `User` 所有记录：

```ts
const users = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
})
```

以下示例按 `email` 降序排序 `User` 所有记录：

```ts
const users = await prisma.user.findMany({
  orderBy: {
    email: 'desc',
  },
})
```

#### 返回按关联 `User` 记录的 `name` 排序 `Post` 记录

排序关联字段是预览特性。要启用此功能，请在您的模式中添加 `orderByRelation` 到 `previewFeatures`：

```prisma highlight=3;normal
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["orderByRelation"]
}
```

以下查询按用户名对帖子排序：

```ts
const posts = await prisma.post.findMany({
  orderBy: {
    author: {
      name: 'asc',
    },
  },
})
```

#### 按 `posts` 记录数量排序 `User` 记录

排序关联计数(orderBy count)是预览特性。要启用此功能，请在您的模式中添加 `orderByRelation` 到 `previewFeatures`：

```prisma highlight=3;normal
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["orderByRelation"]
}
```

以下查询按帖子数量排序用户：

```ts
const getActiveusers = await prisma.user.findMany({
  orderBy: {
    posts: {
      count: 'desc',
    },
  },
})
```

##### 按多个字段 - `email` _和_ `role` 排序 `User` 记录

以下示例按两个字段排序用户：- 首先按 `email` 排序，然后按 `role` 排序

<CodeWithResult>

<cmd>

```ts
const users = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
  orderBy: [
    {
      email: 'desc',
    },
    {
      role: 'desc',
    },
  ],
})
```

</cmd>

<cmdResult>

```json
[
  {
    "email": "yuki@prisma.io",
    "role": "USER"
  },
  {
    "email": "nora@prisma.io",
    "role": "USER"
  },
  {
    "email": "mary@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "elsa@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "eloise@prisma.io",
    "role": "USER"
  },
  {
    "email": "coco@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "anna@prisma.io",
    "role": "USER"
  },
  {
    "email": "alice@prisma.io",
    "role": "USER"
  }
]
```

</cmdResult>

</CodeWithResult>

排序参数的顺序很重要 - 以下查询按 `role`排序后，再按 `email` 排序。不是结果的差异：

<CodeWithResult>

<cmd>

```ts
const users = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
  orderBy: [
    {
      role: 'desc',
    },
    {
      email: 'desc',
    },
  ],
})
```

</cmd>

<cmdResult>

```json
[
  {
    "email": "mary@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "elsa@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "yuki@prisma.io",
    "role": "USER"
  },
  {
    "email": "nora@prisma.io",
    "role": "USER"
  },
  {
    "email": "eloise@prisma.io",
    "role": "USER"
  },
  {
    "email": "anna@prisma.io",
    "role": "USER"
  },
  {
    "email": "alice@prisma.io",
    "role": "USER"
  },
  {
    "email": "coco@prisma.io",
    "role": "ADMIN"
  }
]
```

</cmdResult>

</CodeWithResult>

##### 按 `email`，选择 `name` 和 `email` 排序 `User` 记录

以下示例按 `email` 排序所有 `User` 记录，然后返回 `name` 和 `email` 字段：

<CodeWithResult>

<cmd>

```ts
const users3 = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
  select: {
    name: true,
    email: true,
  },
})
```

</cmd>

<cmdResult>

```js
;[
  {
    name: 'Alice',
    email: 'alice@prisma.io',
  },
  {
    name: 'Ariadne',
    email: 'ariadne@prisma.io',
  },
  {
    name: 'Bob',
    email: 'bob@prisma.io',
  },
]
```

</cmdResult>

</CodeWithResult>

##### 按 `email` 排序 `User` 记录，并按 `title` 排序嵌套的 `Post` 记录

下面的例子：

- 返回所有 `User` 记录按 `email` 排序
- 对于每个 `User` 记录，返回按 `title` 排序的所有嵌套 `Post` 记录的 `title` 字段

<CodeWithResult>

<cmd>

```ts
const usersWithPosts = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
  include: {
    posts: {
      select: {
        title: true,
      },
      orderBy: {
        title: 'asc',
      },
    },
  },
})
```

</cmd>

<cmdResult>

```json
[
  {
    "id": 2,
    "email": "alice@prisma.io",
    "name": "Alice",
    "posts": [
      {
        "title": "Watch the talks from Prisma Day 2019"
      }
    ]
  },
  {
    "id": 3,
    "email": "ariadne@prisma.io",
    "name": "Ariadne",
    "posts": [
      {
        "title": "How to connect to a SQLite database"
      },
      {
        "title": "My first day at Prisma"
      }
    ]
  },
  {
    "id": 1,
    "email": "bob@prisma.io",
    "name": "Bob",
    "posts": [
      {
        "title": "Follow Prisma on Twitter"
      },
      {
        "title": "Subscribe to GraphQL Weekly for community news "
      }
    ]
  }
]
```

</cmdResult>

</CodeWithResult>

##### 排序一个用户的嵌套的 `Post` 记录列表

以下示例按 ID 检索一个 `User` 记录，以及按 `title` 排序嵌套的 `Post` 记录列表。

<CodeWithResult>

<cmd>

```ts
const userWithPosts = await prisma.user.findUnique({
  where: {
    id: 1,
  },
  include: {
    posts: {
      orderBy: {
        title: 'desc',
      },
      select: {
        title: true,
        published: true,
      },
    },
  },
})
```

</cmd>

<cmdResult>

```json
{
  "email": "sarah@prisma.io",
  "id": 1,
  "name": "Sarah",
  "extendedProfile": null,
  "role": "USER",
  "posts": [
    {
      "title": "Prisma Day 2020",
      "published": false
    },
    {
      "title": "My first post",
      "published": false
    },
    {
      "title": "All about databases",
      "published": true
    }
  ]
}
```

</cmdResult>

</CodeWithResult>

##### 排序按 `enum`

以下示例排序所有 `User` 记录按 `role` (是一个 `enum`)：

<CodeWithResult>

<cmd>

```ts
const sort = await prisma.user.findMany({
  orderBy: {
    role: 'desc',
  },
  select: {
    email: true,
    role: true,
  },
})
```

</cmd>

<cmdResult>

```json
[
  {
    "email": "emma@prisma.io",

    "role": "USER"
  },
  {
    "email": "suma@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "kwame@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "pearl@prisma.io",
    "role": "ADMIN"
  }
]
```

</cmdResult>

</CodeWithResult>

#### `orderBy` 的生成类型

以下示例演示了如何将 [`validator`](../../concepts/components/prisma-client/advanced-type-safety/prisma-validator) 与 `orderBy` 结合使用：

- `UserOrderByInput`
  ```ts
  const orderEmailsByDescending = Prisma.validator<Prisma.UserOrderByInput>()({
    email: 'desc',
  })
  ```

### <inlinecode>distinct</inlinecode>

参见：[聚合，分组和汇总](../../../concepts/components/prisma-client/aggregation-grouping-summarizing#select-distinct) <span class="concept"></span>

#### 参考

```ts file=index.d.ts
distinct?: Enumerable<UserDistinctFieldEnum>
```

```ts
export declare const UserDistinctFieldEnum: {
  id: 'id'
  name: 'name'
  email: 'email'
  profileViews: 'profileViews'
  role: 'role'
  coinflips: 'coinflips'
}
```

#### 例子

##### 在单个字段上选择不同的内容（去重）

以下示例返回所有不同的 `city` 字段，并仅选择 `city` 和 `country` 字段：

<CodeWithResult  expanded={true}>

<cmd>

```ts
const distinctCities = await prisma.user.findMany({
  select: {
    city: true,
    country: true,
  },
  distinct: ['city'],
})
```

</cmd>

<cmdResult>

```js no-lines
;[
  { city: 'Paris', country: 'France' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

##### 在多个字段上选择不同

以下示例返回所有不同的 `city` _和_ `country` 字段组合，并仅选择 `city` 和 `country` 字段：

<CodeWithResult expanded={true}>

<cmd>

```ts
const distinctCitiesAndCountries = await prisma.user.findMany({
  select: {
    city: true,
    country: true,
  },
  distinct: ['city', 'country'],
})
```

</cmd>

<cmdResult>

```js no-lines
;[
  { city: 'Paris', country: 'France' },
  { city: 'Paris', country: 'Denmark' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

请注意，现在有一个 "Paris, Denmark" 了，而不是 "Paris, France"：

##### 结合过滤器选择不同

以下示例返回所有不同的 `city` _和_ `country` 字段组合，过滤出其中包含 `"prisma.io"` 的用户的邮件，并仅选择 `city` 和 `country` 字段：

<CodeWithResult>

<cmd>

```ts
const distinctCitiesAndCountries = await prisma.user.findMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  select: {
    city: true,
    country: true,
  },
  distinct: ['city', 'country'],
})
```

</cmd>

<cmdResult>

```js
;[
  { city: 'Paris', country: 'Denmark' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

## 嵌套查询

### <inlinecode>create</inlinecode>

嵌套的 `create` 查询会添加一个新的关联记录或记录集到父记录。请参见：[使用关系](../../../concepts/components/prisma-client/relation-queries) <span class="concept"></span>。

#### 注意

- 当你 `create`（`prisma.user.create（...）`）一个新的父记录或 `update`（`prisma.user.update（...）`）时，`create`可用作嵌套查询现有的父记录。

> 你可以使用一个嵌套的 `create` _或_ `createMany` 来创建多个相关记录 - [每种方法的优缺点](././concepts/components/prisma-client/relation-queries/#create-a-single-record-and-multiple-related-records) <span class="concept"></span>。

#### 例子

##### 创建一条新的 `User` 记录，并且创建一条新的 `Profile` 记录

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    profile: {
      create: { bio: 'Hello World' },
    },
  },
})
```

##### 创建一条新的 `Profile` 记录，并且创建一条新的 `User` 记录

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
|     create: { email: 'alice@prisma.io' },
    },
  },
})
```

##### 创建一条新的 `User` 记录，并且创建一条新的 `Post` 记录

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: { title: 'Hello World' },
    },
  },
})
```

##### 创建一条新的 `User` 记录，并且创建两条新的 `Post` 记录

因为它是一对多的关系，您还可以通过将数组传递给 `create` 来一次创建多个 `Post` 记录：

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [
        {
          title: 'This is my first post',
        },
        {
          title: 'Here comes a second post',
        },
      ],
    },
  },
})
```

您还可以使用嵌套的 [`createMany`](#createmany-1) 来实现相同的结果。

##### 通过创建一条新的 `Profile` 记录来更新一个现有的 `User` 记录

```ts highlight=5;normal;
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      create: { bio: 'Hello World' },
    },
  },
})
```

##### 通过创建一条新的 `Post` 记录来更新一个现有的 `User` 记录

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
|      create: { title: 'Hello World' },
    },
  },
})
```

### <inlinecode>createMany</inlinecode>

嵌套的 `createMany` 查询将一组新记录添加到父记录。请参阅：[使用关系](../../../concepts/components/prisma-client/relation-queries) <span class="concept"></span>。

#### 注意

- 当您创建（`prisma.user.create(...)`）新的父级记录或 `update`（`prisma.user.update(...)`）时，`createMany` 可用作嵌套查询现有的父级记录。
- 在具有多关系的上下文中可用 -例如，您可以 `prisma.user.create(...)` 一个用户并使用嵌套的 `createMany` 创建多个帖子（帖子有一个用户）。
- **不能**在多对多关系的上下文中可用 -例如，您**不能**以`prisma.post.create(...)`一个帖子并使用嵌套的`createMany`创建类别（许多帖子有很多类别）。
- 不支持嵌套额外的关系 - 你不能嵌套额外的 `create` 或 `createMany`。
- 允许直接设置外键 - 例如，在一个帖子上设置 `categoryId`。

> 你可以使用嵌套的 `create` _或_ 嵌套的 `createMany` 来创建多个关联记录 - [每种方法的优缺点](../../concepts/components/prisma-client/relation-queries/#create-a-single-record-and-multiple-related-records) <span class="concept"></span>.

#### 例子

##### 更新一条 `User` 记录并创建多条新的关联 `Post` 记录

```ts
const user = await prisma.user.update({
  where: {
    id: 9,
  },
  data: {
    name: 'Elliott',
    posts: {
      createMany: {
        data: [{ title: 'My first post' }, { title: 'My second post' }],
      },
    },
  },
})
```

### <inlinecode>set</inlinecode>

`set` 覆盖一个关系的值 - 例如，用一个不同的列表替换一个 `Post` 记录的列表。参见: [使用关系](./././concepts/components/prisma-client/relation-queries) <span class="concept"></span>

#### 例子

##### 更新一个现有的 `User` 记录，断开任何以前的 `Post` 记录，并连接另外两个现有的记录。

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      set: [{ id: 32 }, { id: 42 }],
    },
  },
})
```

### <inlinecode>connect</inlinecode>

<AlgoliaTerm name="apiReference" value="connect" />

嵌套的 `connect` 查询通过指定 ID 或唯一标识符将一条记录连接到现有的相关记录。参见: [使用关系](.../.../concepts/components/prisma-client/relation-queries) <span class="concept"></span>。

#### 注意

- 当你创建一个新的父记录或更新一个现有的父记录时，`connect` 可以作为一个嵌套查询。
- 如果相关记录不存在，Prisma Client 会抛出一个异常。

  ```
  The required connected records were not found. Expected 1 records to be connected, found 0.
  ```

#### 例子

##### 创建一条新的 `Profile` 记录并通过唯一字段将其连接到一个现有的 `User` 记录

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})
```

##### 创建一条新的 `Profile` 记录并通过 ID 字段将其连接到一个现有的 `User` 记录

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      connect: { id: 42 }, // sets userId of Profile record
    },
  },
})
```

在 [2.11.0](https://github.com/prisma/prisma/releases/2.11.0)及更高版本，你可以直接设置外键。

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    userId: 42,
  },
})
```

##### 创建一条新的 `Post` 记录并连接到一个现有的 `User` 记录

```ts
const user = await prisma.post.create({
  data: {
    title: 'Hello World',
    author: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})
```

##### 更新一条现有的 `User` 记录，并将其连接到一个现有的 `Profile` 记录

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      connect: { id: 24 },
    },
  },
})
```

##### 更新一条现有的 `User` 记录，并将其连接到两个现有的 `Post` 记录

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      connect: [{ id: 24 }, { id: 42 }],
    },
  },
})
```

### <inlinecode>connectOrCreate</inlinecode>

<AlgoliaTerm name="apiReference" value="connectOrCreate" />

`connectOrCreate` 通过 ID 或唯一标识符将一条记录连接到现有的相关记录，或者如果该记录不存在，则创建一个新的相关记录。参见。[使用关系](.../.../concepts/components/prisma-client/relation-queries) <span class="concept"></span>。

#### 注意

<!-- prettier-ignore-start -->

- 运行 _作为并发事务_ 的多个 `ConnectCreate` 查询可能会导致**竞争条件** 。考虑以下示例，其中两个查询尝试同时 `connectOrCreate` 一个名为 `computing` 的博客文章标签（标签名称必须是唯一的）：

  <TabbedContent tabs={[<FileWithIcon text="Query A" icon="code"/>, <FileWithIcon text="Query B" icon="code"/>]}>
  <tab>

  ```ts
  const createPost = await prisma.post.create({
    data: {
      title: 'How to create a compiler',
      content: '...',
      author: {
        connect: {
          id: 9,
        },
      },
      tags: {
        connectOrCreate: {
          create: {
            name: 'computing',
          },
          where: {
            name: 'computing',
          },
        },
      },
    },
  })
  ```

  </tab>
    <tab>

  ```ts
  const createPost = await prisma.post.create({
    data: {
      title: 'How to handle schema drift in production',
      content: '...',
      author: {
        connect: {
          id: 15,
        },
      },
      tags: {
        connectOrCreate: {
          create: {
            name: 'computing',
          },
          where: {
            name: 'computing',
          },
        },
      },
    },
  })
  ```

  </tab>
  </TabbedContent>

  如果查询 A 和查询 B 在以下方式重叠，查询 A 结果会导致异常：

  | 查询 A (失败 ❌)                                                | 查询 B (成功 ✅)                                             |
  | :--------------------------------------------------------------- | :--------------------------------------------------------------- |
  | 查询到达服务器，启动事物 A                          | 查询到达服务器，启动事物 B                          |
  |                                                                  | 查找 `tagName` 等于 `computing` 的记录，未找到记录 |
  | 查找 `tagName` 等于 `computing` 的记录，未找到记录 |                                                                  |
  |                                                                  | 创建 `tagName` 等于 `computing` 的记录并连接     |
  | 创建 `tagName` 等于 `computing` 的记录                 |                                                                  |
  | 唯一的违规异常, 记录已由事物 B 创建        |                                                                  |

  绕过这种情况，我们建议捕获唯一的违规异常（`PrismaClientKnownRequestError`，错误 `p2002`）和重试失败的查询。

<!-- prettier-ignore-end -->

#### 例子

##### 创建一个新的 `Profile` 记录，然后将其连接到一个现有的 `User` 记录，*或者*创建一个新的 `User`

以下示例：

1. 创建一个 `Profile`
2. 尝试将 `Profile` 连接到 `User`，其中电子邮件地址是 `Alice@Prisma.io`
3. 如果匹配的用户不存在，则创建一个新的用户

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'The coolest Alice on the planet',
    user: {
      connectOrCreate: {
        where:  { email: 'alice@prisma.io' },
        create: { email: 'alice@prisma.io'}
    },
  },
})
```

##### 创建一个新的 `Post` 记录并将其连接到一个现有的 `User` 记录，*或者*创建一个新的 `User`

```ts
const user = await prisma.post.create({
  data: {
    title: 'Hello World',
    author: {
      connectOrCreate: {
        where: { email: 'alice@prisma.io' },
        create: { email: 'alice@prisma.io' },
      },
    },
  },
})
```

##### 更新现有的 `User` 记录，将其与现有的 `Profile` 记录连接起来，*或*创建一个新的 `Profile` 记录。

以下示例：

2. 尝试连接 `id` 为 `20` 的用户到一个 `Profile`
3. 如果匹配的 profile 不存在，则创建一个 profile

```ts
const updateUser = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      connectOrCreate: {
        where: { id: 20 },
        create: {
          bio: 'The coolest Alice in town',
        },
      },
    },
  },
})
```

##### 通过将现有的 `User` 记录连接到两个 `Post` 记录，或创建两个新的 `Post` 记录，来更新一个现有的 `User` 记录

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      connectOrCreate: [
        {
          where: { id: 32 },
          create: { title: 'This is my first post' },
        },
        {
          where: { id: 19 },
          create: { title: 'This is my second post' },
        },
      ],
    },
  },
})
```

### <inlinecode>disconnect</inlinecode>

<AlgoliaTerm name="apiReference" value="disconnect" />

嵌套的 `disconnect` 查询中断父记录和相关记录之间的连接，但不会删除任一记录。请参阅：[使用关联](../../../concepts/components/prisma-client/relation-queries) <span class="concept"></span>

#### 注意

- `disconnect` 仅在关系是可选的情况下可用。
- 如果您试图断开的关系不存在:

  - ([在 2.21.0 和更高版本](https://github.com/prisma/prisma/releases/tag/2.21.0))，什么操作也不做
  - ([2.21.0 之前](https://github.com/prisma/prisma/releases/tag/2.21.0)) 如果提供的 ID 或唯一标识符没有连接，Prisma Client 抛出异常:

    ```
    The records for relation `PostToUser` between the `User` and `Post` models are not connected.
    ```

#### 例子

##### 通过断开连接的 `Profile` 记录来更新现有的 `User` 记录

```ts
const user = await prisma.user.update({
  where: { email: 'bob  @prisma.io' },
  data: {
    profile: {
      disconnect: true,
    },
  },
})
```

##### 通过断开连接的两个 `Post` 记录来更新一个现有的 `User` 记录

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      disconnect: [{ id: 44 }, { id: 46 }],
    },
  },
})
```

### <inlinecode>update</inlinecode>

<AlgoliaTerm name="apiReference" value="update" />

嵌套的 `update` 查询更新一个或多个相关记录，其中父记录的 ID 为 `n`。参见：[使用关系](../../../concepts/components/prisma-client/relation-queries#update-a-specific-related-record) <span class="concept"></span>

#### 注意

- 嵌套的 `update` 查询只在顶级 `update` 查询的上下文中可用 (例如，' prisma.user.update(…)')。
- 如果父记录不存在，Prisma Client 抛出异常:

  ```
  AssertionError("Expected a valid parent ID to be present for nested update to-one case.")
  ```

- 如果要更新的相关记录不存在，Prisma Client 抛出异常:

  ```
  AssertionError("Expected a valid parent ID to be present for nested update to-one case.")
  ```

#### 例子

##### 通过更新连接到的 `Profile` 记录来更新现有的 `User` 记录

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      update: { bio: 'Hello World' },
    },
  },
})
```

##### 通过更新连接到的两个 `Post` 记录来更新一个现有的 `User` 记录

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      update: [
        {
          data: { published: true },
          where: { id: 32 },
        },
        {
          data: { published: true },
          where: { id: 23 },
        },
      ],
    },
  },
})
```

### <inlinecode>upsert</inlinecode>

<AlgoliaTerm name="apiReference" value="upsert" />

嵌套的 `upsert` 查询在相关记录存在的情况下更新相关记录，或者创建新的相关记录。

#### 例子

##### 通过更新连接到的 `Profile` 记录或创建一个新记录来更新现有的 `User` 记录 (_upsert_)

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      upsert: {
        create: { bio: 'Hello World' },
        update: { bio: 'Hello World' },
      },
    },
  },
})
```

##### 通过更新两个已连接的 `Post` 记录或创建新的 `User` 记录来更新现有的 `User` 记录 (_upsert_)

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      upsert: [
        {
          create: { title: 'This is my first post' },
          update: { title: 'This is my first post' },
          where: { id: 32 },
        },
        {
          create: { title: 'This is mt second post' },
          update: { title: 'This is mt second post' },
          where: { id: 23 },
        },
      ],
    },
  },
})
```

### <inlinecode>delete</inlinecode>

<AlgoliaTerm name="apiReference" value="delete" />

嵌套的 `delete` 查询删除相关记录。父记录没有被删除。

#### 注意

- `delete` 仅在关系是可选的情况下可用。

#### 例子

##### 更新现有的 `User` 记录，删除连接到的 `Profile` 记录。

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      delete: true,
    },
  },
})
```

##### 更新现有的 `User` 记录，删除连接到的两条 `Post` 记录。

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      delete: [{ id: 34 }, { id: 36 }],
    },
  },
})
```

### <inlinecode>updateMany</inlinecode>

<AlgoliaTerm name="apiReference" value="updateMany" />

嵌套的 `updateMany` 更新相关记录列表并支持过滤 — 例如，你可以更新用户未发布的帖子。

#### 例子

##### 更新属于特定用户的所有未发布的帖子

```ts
const result = await prisma.user.update({
  where: {
    id: 2,
  },
  data: {
    posts: {
      updateMany: {
        where: {
          published: false,
        },
        data: {
          likes: 0,
        },
      },
    },
  },
})
```

### <inlinecode>deleteMany</inlinecode>

<AlgoliaTerm name="apiReference" value="deleteMany" />

嵌套的 `deleteMany` 删除相关记录并支持过滤。例如，您可以删除用户的帖子，同时更新该用户的其他属性。

#### 例子

##### 删除所有属于特定用户的帖子作为更新的一部分

```ts
const result = await prisma.user.update({
  where: {
    id: 2,
  },
  data: {
    name: 'Updated name',
    posts: {
      deleteMany: {},
    },
  },
})
```

## 过滤条件和运算符

### <inlinecode>equals</inlinecode>

值等于 `n`.

#### 例子

##### 返回所有 `name` 等于 `"Eleanor"` 的用户

```ts
const result = await prisma.user.findMany({
  where: {
    name: {
      equals: 'Eleanor',
    },
  },
})
```

你还可以排除 `equals`：

```ts
const result = await prisma.user.findMany({
  where: {
    name: 'Eleanor',
  },
})
```

### <inlinecode>not</inlinecode>

值不等于 `n`.

#### 例子

##### 返回所有 `name` **不等于** `"Eleanor"` 的用户

```ts
const result = await prisma.user.findMany({
  where: {
    name: {
      not: 'Eleanor',
    },
  },
})
```

### <inlinecode>in</inlinecode>

值 `n` 存在于列表中。

#### 注意

- `null` 不会被返回。例如，如果你结合 `in` 和 `NOT` 来返回名字**不在**列表中的用户，将不会返回名字为 `null` 的用户。

#### 例子

##### 获取 `id` 可以在以下列表中找到 `[22, 91, 14, 2, 5]` 的 `User` 记录

```ts
const getUser = await prisma.user.findMany({
  where: {
    id: { in: [22, 91, 14, 2, 5] },
  },
})
```

##### 获取 `name` 可以在以下列表中找到 `['Saqui', 'Clementine', 'Bob']` 的 `User` 记录

```ts
const getUser = await prisma.user.findMany({
  where: {
    name: { in: ['Saqui', 'Clementine', 'Bob'] },
  },
})
```

##### 获取 `User` 记录，其 `name` **不存在**列表中

以下示例结合 `in` 和 [`NOT`](#not)。你还可以使用 [`notIn`](#notin)。

```ts
const getUser = await prisma.user.findMany({
  where: {
    NOT: {
      name: { in: ['Saqui', 'Clementine', 'Bob'] },
    },
  },
})
```

##### 获取一个 `User` 记录，其至少有一个 `Post` 包含至少一个指定的 `Category`

```ts
const getUser = await prisma.user.findMany({
  where: {
    // 查找用户在哪里...
    posts: {
      some: {
        // ..至少一个（一些）帖子..
        categories: {
          some: {
            // .. 至少有一个类别..
            name: {
              in: ['Food', 'Introductions'], // .. 具有与以下之一匹配的名称。
            },
          },
        },
      },
    },
  },
})
```

### <inlinecode>notIn</inlinecode>

值 `n` 不存在于列表中。

#### 注意

- `null` 值是不会被返回的。

#### 例子

##### 获取 `id` **不能**在以下列表中找到：`[22, 91, 14, 2, 5]` 的 `User` 记录

```ts
const getUser = await prisma.user.findMany({
  where: {
    id: { notIn: [22, 91, 14, 2, 5] },
  },
})
```

### <inlinecode>lt</inlinecode>

值 `n` 小于 `x`。

#### 例子

##### 获取所有 `likes` 小于 `9` 的 `Post` 记录

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      lt: 9,
    },
  },
})
```

### <inlinecode>lte</inlinecode>

值 `n` 小于*或*等于 `x`。

#### 例子

##### 获取所有 `likes` 小于或等于 `9` 的 `Post` 记录

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      lte: 9,
    },
  },
})
```

### <inlinecode>gt</inlinecode>

值 `n` 大于 `x`。

#### 例子

##### 获取所有 `likes` 大于 `9` 的 `Post` 记录

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      gt: 9,
    },
  },
})
```

### <inlinecode>gte</inlinecode>

值 `n` 大于*或*等于 `x`。

#### 例子

##### 获取所有 `likes` 大于或等于 `9` 的 `Post` 记录

```ts
const getPosts = await prisma.post.findMany({
  where: {
    likes: {
      gte: 9,
    },
  },
})
```

#### 例子

##### 获取所有 `date_created` 大于 2020 年 3 月 19 日 的 `Post` 记录

```js
const result = await prisma.post.findMany({
  where: {
    date_created: {
      gte: new Date('2020-03-19T14:21:00+0200') /* 包括 UTC 的时间偏移 */,
    },
  },
})
```

### <inlinecode>contains</inlinecode>

值 `n` 包含 `x`。

#### 例子

##### 统计所有 `content` 包含 `databases` 的 `Post` 记录的数量

```js
const result = await prisma.post.count({
  where: {
    content: {
      contains: 'databases',
    },
  },
})
```

##### 统计所有 `content` 不包含 `databases` 的 `Post` 记录的数量

```js
const result = await prisma.post.count({
  where: {
    NOT: {
      content: {
        contains: 'databases',
      },
    },
  },
})
```

### <inlinecode>mode</inlinecode>

#### 注意

- 仅支持 PostgreSQL 和 MongoDB 连接器

#### 例子

##### 获取所有 `title` 包含 `prisma` 的 `Post` 记录，不区分大小写

```js
const result = await prisma.post.findMany({
  where: {
    title: {
      contains: 'prisma',
      mode: 'insensitive',
    },
  },
})
```

### <inlinecode>startsWith</inlinecode>

#### 例子

##### 获取所有 `title` 以 `Pr` 开头的 `Post` 记录（例如 `Prisma`）

```js
const result = await prisma.post.findMany({
  where: {
    title: {
      startsWith: 'Pr',
    },
  },
})
```

### <inlinecode>endsWith</inlinecode>

#### 获取所有 `email` 结尾为 `prisma.io` `User` 记录

```js
const result = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
    },
  },
})
```

### <inlinecode>AND</inlinecode>

所有条件必须返回 `true`。 另外，在 `where` 条件中传递对象列表 - 这个[`AND` 操作符不是必需的](#get-all-post-records-where-the-content-field-contains-prisma-and-published-is-false-no-and)。

#### 例子

##### 获取所有 `content` 字段包含 `Prisma` 并且 `published` 为 `false` 的 `Post` 记录

```js
const result = await prisma.post.findMany({
  where: {
    AND: [
      {
        content: {
          contains: 'Prisma',
        },
      },
      {
        published: {
          equals: false,
        },
      },
    ],
  },
})
```

##### 获取所有 `content` 字段包含 `Prisma` 并且 `published` 为 `false`（没有 `AND`） 的 `Post` 记录

以下格式返回与上一个例子相同结果（不使用 `AND` 来写）：

```js
const result = await prisma.post.findMany({
  where: {
    content: {
      contains: 'Prisma',
    },
    published: {
      equals: false,
    },
  },
})
```

##### 获取所有 `title` 字段包含 `Prisma` 或 `databases`，并且 `published` 为 `false` 的 `Post` 记录

以下示例结合了 `OR` 和 `AND`：

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    AND: {
      published: false,
    },
  },
})
```

### <inlinecode>OR</inlinecode>

一个或多个条件必须返回 `true`。

#### 例子

##### 获取所有 `title` 字段包含 `Prisma` 或 `databases` 的 `Post` 记录

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
  },
})
```

##### 获取所有 `title` 字段包含 `Prisma` 或 `databases`，但不包含 `SQL` 的 `Post` 记录

以下示例结合了 `OR` 和 `NOT`：

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
  },
})
```

##### 获取所有 `title` 字段包含 `Prisma` 或 `databases`，并且 `published` 为 `false` 的 `Post` 记录

以下示例结合了 `OR` 和 `AND`：

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    AND: {
      published: false,
    },
  },
})
```

### <inlinecode>NOT</inlinecode>

所有条件必须返回 `false`。

#### 例子

##### 获取所有 `title` 字段包含 `Prisma` 或 `databases`，但不包含 `SQL` 的 `Post` 记录

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
  },
})
```

##### 获取所有 `title` 字段包含 `Prisma` 或 `databases`，但不包含 `SQL`，并且关联的 `User` 记录的邮箱地址不包含 `sarah` 的 `Post` 记录

```js
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    NOT: {
      title: {
        contains: 'SQL',
      },
    },
    user: {
      NOT: {
        email: {
          contains: 'sarah',
        },
      },
    },
  },
  include: {
    user: true,
  },
})
```

## 关联过滤

### <inlinecode>some</inlinecode>

返回 **一个或多个** ("some") *关联*匹配过滤条件的所有记录。

#### 注意

- 你可以使用 `some` 不带参数返回至少有一个关系的所有记录

#### 参考

```ts file=index.d.ts
export type PostFilter = {
  every?: PostWhereInput | null
|  some?: PostWhereInput | null
  none?: PostWhereInput | null
}
```

#### 例子

##### 获取 _所有_ 的 `Post` 记录已发布，并且至少一个关联的 `Post` 记录提到了 `Prisma` 的 `User` 记录

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
      every: {
        published: true
      },
      some: {
        content: {
          contains: "Prisma"
        }
      }
    }
  }
}
```

### <inlinecode>every</inlinecode>

返回 **所有** ("every") *关联*匹配过滤条件的所有记录。

#### 参考

```ts file=index.d.ts
export type PostFilter = {
|  every?: PostWhereInput | null
  some?: PostWhereInput | null
  none?: PostWhereInput | null
}
```

#### 例子

##### 获取 _所有_ 的 `Post` 记录已发布，并且至少一个关联的 `Post` 记录提到了 `Prisma` 的 `User` 记录

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
      every: {
        published: true
      },
      some: {
        content: {
          contains: "Prisma"
        }
      }
    }
  }
}
```

### <inlinecode>none</inlinecode>

返回所有记录，其中 **零** 个关联记录匹配过滤条件。

#### 注意

- 可以使用不带参数的 `none` 来[返回所有没有关系的记录](#get-all-user-records-with-zero-posts)

#### 参考

```ts file=index.d.ts
export type PostFilter = {
  every?: PostWhereInput | null
  some?: PostWhereInput | null
|  none?: PostWhereInput | null
}
```

#### 例子

##### 获取所有不关联的 `Post` 记录的 `User` 记录

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
        none: {} // User has no posts
    }
  }
}
```

##### 获取所有未发布的 `Post` 记录的 `User` 记录

```ts
const result = await prisma.user.findMany({
  where: {
    post: {
        none: {
          published: true
        }
    }
  }
}
```

### <inlinecode>is</inlinecode>

返回所有匹配过滤条件的关联记录（例如，用户的名字是(`is`) Bob）。

#### 参考

```ts file=index.d.ts highlight=2;normal
export type UserRelationFilter = {
  is?: UserWhereInput | null
  isNot?: UserWhereInput | null
}
```

#### 例子

##### 获取所有名称是 `"Bob"` 的 `Post` 记录

```ts
const result = await prisma.post.findMany({
  where: {
    user: {
        is: {
          name: "Bob"
        },
    }
  }
}
```

### <inlinecode>isNot</inlinecode>

返回所有匹配过滤条件的关联记录（例如，用户的名字不是(`isNot`) Bob）。

#### 参考

```ts file=index.d.ts highlight=3;normal
export type UserRelationFilter = {
  is?: UserWhereInput | null
  isNot?: UserWhereInput | null
}
```

#### 例子

##### 获取所有用户的名字不是 `"Bob"` 的 `Post` 记录

```ts
const result = await prisma.post.findMany({
  where: {
    user: {
        isNot: {
          name: "Bob"
        },
    }
  }
}
```

## 标量列表方法

### 参考

```ts
export type PostUpdatetagsInput = {
  set?: Enumerable<string>
  push?: string
}
```

### <inlinecode>set</inlinecode>

使用 `set` 来覆盖一个标量列表字段的值。

#### 注意

- `set` 是可选的 - 你可以直接设置值：

  ```ts
  tags: ['computers', 'books']
  ```

#### 例子

##### 将 `tags` 的值设置为字符串值列表

```ts
const setTags = await prisma.post.update({
  where: {
    id: 9
  },
  data: {
      tags: {
        set: ["computing", "books"]
      }
    }
  })
}
```

##### 将 `tags` 设置为一个值的列表，_而不_ 使用 `set` 关键字。

```ts
const setTags = await prisma.post.update({
  where: {
    id: 9
  },
  data: {
      tags: ["computing", "books"]
    }
  })
}
```

#### 将 `tags` 的值设置为单个字符串值

```ts
const setTags = await prisma.post.update({
  where: {
    id: 9,
  },
  data: {
    tags: {
      set: 'computing',
    },
  },
})
```

### <inlinecode>push</inlinecode>

`push` 在[2.20.0](https://github.com/prisma/prisma/releases/2.20.0)及更高版本中可用. 使用 `push` 将 _一个_ 值添加到标量列表字段。

#### 注意

- 仅适用于 PostgreSQL。
- 您不能使用值列表 - 只能使用一个值。

#### 例子

##### 将 `computing` 项添加 ​​ 到 `tags` 列表

```ts
const addTag = await prisma.post.update({
  where: {
    id: 9,
  },
  data: {
    tags: {
      push: 'computing',
    },
  },
})
```

## 标量列表过滤

标量列表过滤允许您通过列表 / 数组字段的内容过滤。

<Admonition type="warning">

**注意**: 仅可用于 **PostgreSQL**数据库连接器 且 Prisma [2.15.0](https://github.com/prisma/prisma/releases/tag/2.15.0) 和更高版本.

</Admonition>

### 注意

- 标量列表/数组过滤[忽略 `NULL` 值](../../../concepts/components/prisma-client/working-with-fields/working-with-scalar-lists-arrays#null-values-in-arrays) <span class="concept"></span>。使用 `isEmpty` 或 `NOT` 不会返回带有 `NULL` 值列表/数组的记录，并且 `{ equals: null }` 会导致错误。

### 参考

```ts file=index.d.ts
export type StringNullableListFilter = {
  equals?: Enumerable<string> | null
  has?: string | null
  hasEvery?: Enumerable<string>
  hasSome?: Enumerable<string>
  isEmpty?: boolean
}
```

```ts file=index.d.ts
export type BoolNullableListFilter = {
  equals?: Enumerable<boolean> | null
  has?: boolean | null
  hasEvery?: Enumerable<boolean>
  hasSome?: Enumerable<boolean>
  isEmpty?: boolean
}
```

### <inlinecode>has</inlinecode>

给定的值存在于列表中

#### 例子

以下查询返回所有 `Post` 记录，其中 `tags` 列表包含 `"database"`:

```ts
const posts = await client.post.findMany({
  where: {
    tags: {
      has: 'databases',
    },
  },
})
```

以下查询返回所有 `Post` 记录，其中 `tags` 列表 **不** 包含 `"database"`:

```ts
const posts = await client.post.findMany({
  where: {
    NOT: {
      tags: {
        has: 'databases',
      },
    },
  },
})
```

### <inlinecode>hasEvery</inlinecode>

每个值都存在于列表中。

#### 例子

以下查询返回所有 `Post` 记录，其中 `tags` 列表包含 _至少_ `"database"` _和_ `"typescript"`:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      hasEvery: ['databases', 'typescript'],
    },
  },
})
```

### <inlinecode>hasSome</inlinecode>

列表中至少有一个值存在。

#### 例子

以下查询返回所有 `Post` 记录，其中 `tags` 列表 `"database"` _或_ `"typescript"`:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      hasSome: ['databases', 'typescript'],
    },
  },
})
```

### <inlinecode>isEmpty</inlinecode>

该列表是空的。

#### 例子

以下查询返回所有 `Post` 记录，其中 `tags` 列表是空的:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      isEmpty: true,
    },
  },
})
```

### <inlinecode>equals</inlinecode>

该列表与给定值完全匹配。

#### 例子

以下查询返回所有 `Post` 记录，其中 `tags` 列表只有 `"database"` 和 `"typescript"`:

```ts
const posts = await prisma.post.findMany({
  where: {
    tags: {
      equals: ['databases', 'typescript'],
    },
  },
})
```

## 原子序数运算

更新的原子操作可用于数字字段类型（`Float` 和 `Int`）。此功能允许您根据其 **当前**值（例如 _减法_ 或 _除法_）更新字段，而不会冒竞争条件的风险。

<details><summary>概述：竞争条件</summary>

当两个或多个操作必须按顺序完成才能完成一项任务时，就会发生竞争条件。在以下示例中，两个客户端尝试将同一字段 (`postCount`) 加 1：

| 客户端   | 选项            | 值     |
| :------- | :-------------- | :----- |
| 客户端 1 | **获取** 属性值 | `21`   |
| 客户端 2 | **获取** 属性值 | `21`   |
| 客户端 2 | **设置** 属性值 | `22`   |
| 客户端 1 | **设置** 属性值 | `22` ✘ |

值*应该*是 `23`，但这两个客户端并没有依次读写 `postCount` 字段。更新的原子操作将读和写合并为一个操作，这可以防止竞赛条件。

| 客户端   | 选项                  | 值                 |
| :------- | :-------------------- | :----------------- |
| 客户端 1 | **获取并设置** 属性值 | `21` &rarr; `22`   |
| 客户端 2 | **获取并设置** 属性值 | `22` &rarr; `23` ✔ |

</details>

### 操作

| 选项        | 描述                                        |
| :---------- | :------------------------------------------ |
| `increment` | 将 `n` 添加到当前值。                       |
| `decrement` | 从当前值减去 `n`。                          |
| `multiply`  | 将当前值乘以 `n`。                          |
| `divide`    | 将当前值除以 `n`。                          |
| `set`       | 设置当前字段值。与 `{ myField : n }` 相同。 |

### 参考

```ts file=index.d.ts
export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}
```

### 注意

- 您只能对每个字段、每个查询执行 **一个**原子更新。
- 如果一个字段为 `null`，它不会被 `increment`、`decrement`、`multiply` 或 `divide` 更新。

### 例子

#### 将所有 `Post` 记录的 `view` 和 `likes` 字段值都加 1

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      increment: 1,
    },
    likes: {
      increment: 1,
    },
  },
})
```

#### 将所有 `Post` 记录的 `views` 字段值都设置为 `0`

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: {
      set: 0,
    },
  },
})
```

也可以写成：

```ts
const updatePosts = await prisma.post.updateMany({
  data: {
    views: 0,
  },
})
```

## <inlinecode>JSON</inlinecode> 过滤器

有关用例和高级示例，请参阅：[使用 `Json` 字段](../../../concepts/components/prisma-client/working-with-fields/working-with-json-fields) <span class="concepts"></span>

高级`Json` 过滤作为预览功能提供在[2.23.0 及更高版本](https://github.com/prisma/prisma/releases/tag/2.23.0)。在早期版本中，您可以[过滤确切的`Json`字段值](../../../concepts/components/prisma-client/working-with-fields/working-with-json-fields#filter-on-exact-field-value).

要启用高级过滤，请将 `filterJson` 添加到架构中的 `previewFeatures`：

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["filterJson"]
}
```

<Admonition type="warning">

支持[PostgreSQL](../../../concepts/database-connectors/postgresql) <span class="concept"></span> 和 [MySQL](../../../concepts/database-connectors/mysql) <span class="concept"></span> `path` 选项有不同的语法。 PostgreSQL 不支持对数组中的对象键值进行过滤。

</Admonition>

本节中的示例假设 `pet` 字段的值为：

```json
{
  "favorites": {
    "catBreed": "Turkish van",
    "dogBreed": "Rottweiler",
    "sanctuaries": ["RSPCA", "Alley Cat Allies"],
    "treats": [
      { "name": "Dreamies", "manufacturer": "Mars Inc"}
      { "name": "Treatos", "manufacturer": "The Dog People"}
    ]
  },
  "fostered": {
    "cats": ["Bob", "Alice", "Svetlana the Magnificent", "Queenie"]
  },
  "owned": {
    "cats": ["Elliott"]
  }
}
```

### 注意

- JSON 过滤的实现[不同数据库连接器](../../../concepts/components/prisma-client/working-with-fields/working-with-json-fields)
- PostgreSQL 中的过滤区分大小写，尚不支持`mode`

### <inlinecode>path</inlinecode>

`path` 表示特定键的位置。 以下查询返回嵌套的 `favourites` > `dogBreed` 键等于 `"Rottweiler"`.

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'dogBreed'],
      equals: 'Rottweiler',
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.dogBreed',
      equals: 'Rottweiler',
    },
  },
})
```

</tab>
</TabbedContent>

以下查询返回嵌套的 `owned` > `cats` 数组包含 `"Elliott"` 的所有用户。

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['owned', 'cats'],
      array_contains: ['Elliott'],
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.owned.cats',
      array_contains: 'Elliott',
    },
  },
})
```

</tab>
</TabbedContent>

<Admonition type="warning">

仅 MySQL 连接器支持按数组内对象的键值进行过滤（如下）。

</Admonition>

以下查询返回所有用户，其中嵌套的 `favorites` > `treats` 数组包含一个对象，其中 `name` 值为 `"Dreamies"`：

<TabbedContent tabs={[<FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.treats[*].name',
      array_contains: 'Dreamies',
    },
  },
})
```

</tab>

<tab>

</tab>

</TabbedContent>

### <inlinecode>string_contains</inlinecode>

以下查询返回嵌套的 `favorites` > `catBreed` 键值包含 `"Van"` 的所有用户：

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'catBreed'],
      string_contains: 'Van',
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.catBreed',
      string_contains: 'Van',
    },
  },
})
```

</tab>

</TabbedContent>

### <inlinecode>string_starts_with</inlinecode>

以下查询返回嵌套的 `favorites` > `catBreed` 键值以 `"Turkish"` 开头的所有用户：

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'catBreed'],
      string_starts_with: 'Turkish',
    },
  },
})
```

</tab>

<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.catBreed',
      string_starts_with: 'Turkish',
    },
  },
})
```

</tab>

</TabbedContent>

### <inlinecode>string_ends_with</inlinecode>

以下查询返回嵌套的 `favorites` > `catBreed` 键值以 `"Van"` 结尾的所有用户：

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['favorites', 'catBreed'],
      string_ends_with: 'Van',
    },
  },
})
```

</tab>

<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.favorites.catBreed',
      string_ends_with: 'Van',
    },
  },
})
```

</tab>

</TabbedContent>

### <inlinecode>array_contains</inlinecode>

以下查询返回所有在 `sanctuaries` 数组中包含值 `"RSPCA"` 的用户：

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_contains: ['RSPCA'],
    },
  },
})
```

<Admonition type="info">

**注意**：在 PostgresQL 中，`array_contains` 的值必须是一个数组而不是一个字符串，即使该数组只包含一个值。

</Admonition>

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_contains: 'RSPCA',
    },
  },
})
```

</tab>
</TabbedContent>

以下查询返回所有 `sanctuaries` 数组包含 _所有_ 给定数组中的值的用户

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_contains: ['RSPCA', 'Alley Cat Allies'],
    },
  },
})
```

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_contains: ['RSPCA', 'Alley Cat Allies'],
    },
  },
})
```

</tab>
</TabbedContent>

### <inlinecode>array_starts_with</inlinecode>

以下查询返回所有 `sanctuaries` 数组以 `"RSPCA"` 开头的用户：

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_starts_with: ['RSPCA'],
    },
  },
})
```

<Admonition type="info">

**注意**：在 PostgresQL 中，`array startswith` 的值必须是一个数组而不是一个字符串，即使该数组只包含一个值。

</Admonition>

</tab>

<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_starts_with: 'RSPCA',
    },
  },
})
```

</tab>
</TabbedContent>

### <inlinecode>array_ends_with</inlinecode>

以下查询返回所有以 `"Alley Cat Allies"` 值结尾的 `sanctuaries` 数组的用户：

<TabbedContent tabs={[<FileWithIcon text="PostgreSQL" icon="database"/>, <FileWithIcon text="MySQL" icon="database"/>]}>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: ['sanctuaries'],
      array_ends_with: ['Alley Cat Allies'],
    },
  },
})
```

<Admonition type="info">

**注意**：在 PostgresQL 中，`array_ends_with` 的值必须是一个数组而不是一个字符串，即使该数组只包含一个值。

</Admonition>

</tab>
<tab>

```ts
const getUsers = await prisma.user.findMany({
  where: {
    pets: {
      path: '$.sanctuaries',
      array_ends_with: 'Alley Cat Allies',
    },
  },
})
```

</tab>
</TabbedContent>

## 客户端方法(Client methods)

客户端级方法以 `$` 为前缀

<!-- prettier-ignore -->
### <inlinecode>$disconnect()</inlinecode>

`$disconnect()` 方法关闭在调用 `$connect` 时建立的数据库连接，并停止运行 Prisma 查询引擎的进程。见[连接管理](../../..//concepts/components/prisma-client/working-with-prismaclient/connection-management) 了解 `$connect()` 和 `$disconnect()` 的概览。

#### 注意

- `$disconnect()` 返回一个 `Promise`，所以你应该在一个 `async` 函数中使用 `await` 关键字调用它。

#### 参考

```ts
$disconnect(): Promise<void>
```

<!-- prettier-ignore -->
### <inlinecode>$connect()</inlinecode>

`$connect()` 方法通过 Prisma 的查询引擎建立到数据库的物理连接。见【连接管理】(../../..//concepts/components/prisma-client/working-with-prismaclient/connection-management) 了解 `$connect()` 和 `$disconnect()` 的概览。

#### 注意

- `$connect()` 返回一个 `Promise`，所以你应该在一个 `async` 函数中使用 `await` 关键字调用它。

#### 参考

```ts
$connect(): Promise<void>
```

<!-- prettier-ignore -->
### <inlinecode>$on()</inlinecode>

`$on()` 方法允许您订阅事件。有了这些你可以订阅[记录日志](#log) 或 [退出 hooks](../../../concepts/components/prisma-client/working-with-prismaclient/connection-management#exit-hooks).

<!-- prettier-ignore -->
### <inlinecode>$use()</inlinecode>

`$use()` 方法添加了 [中间件](../../../concepts/components/prisma-client/middleware)概念:

```ts
prisma.$use(async (params, next) => {
  console.log('This is middleware!')
  // Modify or interrogate params here

  return next(params)
})
```

#### <inlinecode>next</inlinecode>

`next` 代表中间件堆栈中的“下一级”，可能是下一个中间件或 Prisma 查询，具体取决于[您在堆栈中的位置](../../concepts/components/prisma-client/middleware#running-order-and-the-middleware-stack).

#### <inlinecode>params</inlinecode>

`params` 是一个对象，其中包含要在中间件中使用的信息。

| 范围               | 描述                                                                                            |
| :----------------- | :---------------------------------------------------------------------------------------------- |
| `action`           | 查询类型 -例如，`create` 或 `findMany`。                                                        |
| `args`             | 传递给查询的参数 -例如，`where`、`data` 或 `orderBy`                                            |
| `dataPath`         | 如果您使用[fluent API](../../../concepts/components/prisma-client/relation-queries#fluent-api). |
| `model`            | 模型类型 -例如，`Post` 或 `User`.                                                               |
| `runInTransaction` | 如果查询在 [transaction](#transaction) 的上下文中运行，则返回 `true`。                          |

<Tip>

如果您需要 `model` 属性作为字符串，请使用：`String(params.model)`

</Tip>

示例参数值：

```js
{
  args: { where: { id: 15 } },
  dataPath: [ 'select', 'author', 'select', 'posts' ],
  runInTransaction: false,
  action: 'findMany',
  model: 'Post'
}
```

#### 参考

`params` 接受以下类型：

```ts file=index.d.ts
export type MiddlewareParams = {
  model?: ModelName
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

export declare const ModelName: {
  User: 'User'
  Post: 'Post'
}

export declare type ModelName = typeof ModelName[keyof typeof ModelName]
```

#### 例子

参见：[中间件示例](../../../concepts/components/prisma-client/middleware#examples) <span class="concept"></span>.

<!-- prettier-ignore -->
### <inlinecode>$executeRaw()</inlinecode>

参见：[原始数据库访问 (`$executeRaw()`)](../../../concepts/components/prisma-client/raw-database-access#executeRaw).

<!-- prettier-ignore -->
### <inlinecode>$queryRaw()</inlinecode>

参见：[原始数据库访问 (`$queryRaw()`)](../../../concepts/components/prisma-client/raw-database-access#queryRaw).

<!-- prettier-ignore -->
### <inlinecode>$transaction()</inlinecode>

参见：[事务](../../../concepts/components/prisma-client/transactions).

## 辅助类型

辅助类型是存在于 Prisma 命名空间中的辅助函数和类型。它们对于保持您的应用程序类型安全很有用。

### <inlinecode>Prisma.validator</inlinecode>

`validator` 可帮助您根据架构模型创建可重用的查询参数，同时确保您创建的对象有效。另见：[使用 `Prisma.validator`](../../concepts/components/prisma-client/advanced-type-safety/prisma-validator) <span class="concept"></span>

#### 参考

```ts
export function validator<V>(): <S>(select: Exact<S, V>) => S

type Exact<A, W = unknown> = W extends unknown
  ? A extends Narrowable
    ? Cast<A, W>
    : Cast<
        { [K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never },
        { [K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K] }
      >
  : never

type Narrowable = string | number | boolean | bigint

type Cast<A, B> = A extends B ? A : B

export const type: unique symbol
```

#### 例子

以下示例显示了如何将 `create` 操作提取到自定义函数中以重新使用和接受表单数据：

```ts
import { Prisma } from '@prisma/client'

const createUserAndPost = (
  name: string,
  email: string,
  postTitle: string,
  profileBio: string
) => {
  return Prisma.validator<Prisma.UserCreateInput>()({
    name,
    email,
    posts: {
      create: {
        title: postTitle,
      },
    },
    profile: {
      create: {
        bio: profileBio,
      },
    },
  })
}
```
